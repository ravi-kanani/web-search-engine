skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author adrian bece is a versatile frontend developer with extensive ecommerce experience who is currently working at prototyp where he creates amazing interfaces with … more about adrian … march 19, 2020 leave a comment a practical overview of css houdini 21 min read css, tools, browsers share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → houdini, an umbrella term for the collection of browser apis, aims to bring significant improvements to the web development process and the development of css standards in general. frontend developers will be able to extend the css with new features using javascript, hook into css rendering engine and tell the browser how to apply css during a render process. houdini’s browser support is improving and some apis are available for use today, so it’s a good time to become familiar with them and experiment. we are going to take a look at each part of houdini, its current browser support and see how they can be used today using progressive enhancement. it takes a long time for a new css feature or improvement to progress from an initial draft to a fully-supported and stable css feature that developers can use. javascript-based polyfills can be used as a substitute for the lack of browser support in order to use new css features before they’re officially implemented. but they are flawed in most cases. for example, scrollsnap-polyfill is one of several polyfills that can be used to fix browser support inconsistencies for the css scroll snap specification. but even that solution has some limitations, bugs and inconsistencies. the potential downside to using polyfills is that they can have a negative impact on performance and are difficult to implement properly. this downside is related to the browser’s dom and cssom. browser creates a dom (document object model) from html markup and, similarly, it created cssom (css object model) from css markup. these two object trees are independent of one another. javascript works on dom and has very limited access to cssom. javascript polyfill solutions run only after the initial render cycle has been completed, i.e. when both dom and cssom have been created and the document has finished loading. after polyfill makes changes to styles in the dom (by inlining them), it causes the render process to run again and the whole page re-renders. negative performance impact gets even more apparent if they rely on the requestanimationframe method or depend on user interactions like scroll events. another obstacle in web development is various constraints imposed by the css standards. for example, there are only a limited number of css properties that can be natively animated. css knows how to natively animate colors, but doesn’t know how to animate gradients. there has always been a need to innovate and create impressive web experiences by pushing the boundaries despite the tech limitations. that is why developers often tend to gravitate towards using less-than-ideal workarounds or javascript to implement more advanced styling and effects that are currently not supported by css such as masonry layout, advanced 3d effects, advanced animation, fluid typography, animated gradients, styled select elements, etc. it seems impossible for css specifications to keep up with the various feature demands from the industry such as more control over animations, improved text truncation, better styling option for input and select elements, more display options, more filter options, etc. what could be the potential solution? give developers a native way of extending css using various apis. in this article, we are going to take a look at how frontend developers can do that using houdini apis, javascript, and css. in each section, we’re going to examine each api individually, check its browser support and current specification status, and see how they can be implemented today using progressive enhancement. what is houdini? houdini, an umbrella term for the collection of browser apis, aims to bring significant improvements to the web development process and the development of css standards in general. developers will be able to extend the css with new features using javascript, hook into css rendering engine and tell the browser how to apply css during a render process. this will result in significantly better performance and stability than using regular polyfills. houdini specification consists of two api groups - high-level apis and low-level apis. high-level apis are closely related to the browser’s rendering process (style → layout → paint → composite). this includes: paint api an extension point for the browser’s paint rendering step where visual properties (color, background, border, etc.) are determined. layout api an extension point for the browser’s layout rendering step where element dimensions, position, and alignment are determined. animation api an extension point for browser’s composite rendering step where layers are drawn to the screen and animated. low-level apis form a foundation for high-level apis. this includes: typed object model api custom properties & values api font metrics api worklets some houdini apis are already available for use in some browsers with other apis to follow suit when they’re ready for release. the future of css unlike regular css feature specifications that have been introduced thus far, houdini stands out by allowing developers to extend the css in a more native way. does this mean that css specifications will stop evolving and no new official implementations of css features will be released? well, that is not the case. houdini’s goal is to aid the css feature development process by allowing developers to create working prototypes that can be easily standardized. additionally, developers will be able to share the open-source css worklets more easily and with less need for browser-specific bugfixes. typed object model api before houdini was introduced, the only way for javascript to interact with css was by parsing css represented as string values and modifying them. parsing and overriding styles manually can be difficult and error-prone due to the value type needing to be changed back and forth and value unit needing to be manually appended when assigning a new value. selectedelement.style.fontsize = newfontsize + "px"; // newfontsize = 20
console.log(selectedelement.style.fontsize); // "20px"
 typed object model (typed om) api adds more semantic meaning to css values by exposing them as typed javascript objects. it significantly improves the related code and makes it more performant, stable and maintainable. css values are represented by the cssunitvalue interface which consists of a value and a unit property. {
  value: 20, 
  unit: "px"
}
 this new interface can be used with the following new properties: computedstylemap(): for parsing computed (non-inline) styles. this is a method of selected element that needs to be invoked before parsing or using other methods. attributestylemap: for parsing and modifying inline styles. this is a property that is available on a selected element. // get computed styles from stylesheet (initial value)
selectedelement.computedstylemap().get("font-size"); // { value: 20, unit: "px"}

// set inline styles
selectedelement.attributestylemap.set("font-size", css.em(2)); // sets inline style
selectedelement.attributestylemap.set("color", "blue"); // sets inline style

// computed style remains the same (initial value)
selectedelement.computedstylemap().get("font-size"); // { value: 20, unit: "px"}

// get new inline style
selectedelement.attributestylemap.get("font-size"); // { value: 2, unit: "em"}
 notice how specific css types are being used when setting a new numeric value. by using this syntax, many potential type-related issues can be avoided and the resulting code is more reliable and bug-free. the get and set methods are only a small subset of all available methods defined by the typed om api. some of them include: clear: removes all inline styles delete: removes a specified css property and its value from inline styles has: returns a boolean if a specified css property is set append: adds an additional value to a property that supports multiple values etc. feature detection var selectedelement = document.getelementbyid("example");

if(selectedelement.attributestylemap) {
  /* ... */
}

if(selectedelement.computedstylemap) {
  /* ... */
}
 w3c specification status working draft: published for review by the community browser support google chrome microsoft edge opera browser firefox safari supported supported supported not supported partial support (*) * supported with “experimental web platform features” or other feature flag enabled. data source: is houdini ready yet? custom properties and values api the css properties and values api allows developers to extend css variables by adding a type, initial value and define inheritance. developers can define css custom properties by registering them using the registerproperty method which tells the browsers how to transition it and handle fallback in case of an error. css.registerproperty({ 
  name: "--colorprimary",
  syntax: "<color>", 
  inherits: false,
  initialvalue: "blue",
});
 this method accepts an input argument that is an object with the following properties: name: the name of the custom property syntax: tells the browser how to parse a custom property. these are pre-defined values like <color>, <integer>, <number>, <length>, <percentage>, etc. inherits: tells the browser whether the custom property inherits its parent’s value. initialvalue: tells the initial value that is used until it’s overridden and this is used as a fallback in case of an error. in the following example, the <color> type custom property is being set. this custom property is going to be used in gradient transition. you might be thinking that current css doesn’t support transitions for background gradients and you would be correct. notice how the custom property itself is being used in transition, instead of a background property that would be used for regular background-color transitions. .gradientbox { 
  background: linear-gradient(45deg, rgba(255,255,255,1) 0%, var(--colorprimary) 60%);
  transition: --colorprimary 0.5s ease;
  /* ... */
}

.gradientbox:hover {
  --colorprimary: red
  /* ... */
}
 browser doesn’t know how to handle gradient transition, but it knows how to handle color transitions because the custom property is specified as <color> type. on a browser that supports houdini, a gradient transition will happen when the element is being hovered on. gradient position percentage can also be replaced with css custom property (registered as <percentage> type) and added to a transition in the same way as in the example. if registerproperty is removed and a regular css custom property is registered in a :root selector, the gradient transition won’t work. it’s required that registerproperty is used so the browser knows that it should treat it as color. in the future implementation of this api, it would be possible to register a custom property directly in css. @property --colorprimary { 
  syntax: "<color>"; 
  inherits: false; 
  initial-value: blue;
}
 example this simple example showcases gradient color and position transition on hover event using registered css custom properties for color and position respectively. complete source code is available on the example repository. animated gradient color and position using custom properties & values api. delay for each property added for effect in css transition property. (large preview) feature detection if (css.registerproperty) {
  /* ... */
}
 w3c specification status working draft: published for review by the community browser support google chrome microsoft edge opera browser firefox safari supported supported supported not supported not supported data source: is houdini ready yet? font metrics api the font metrics api is still in a very early stage of development, so its specification may change in the future. in its current draft, font metrics api will provide methods for measuring dimensions of text elements that are being rendered on screen in order to allow developers to affect how text elements are being rendered on screen. these values are either difficult or impossible to measure with current features, so this api will allow developers to create text and font-related css features more easily. multi-line dynamic text truncation is an example of one of those features. w3c specification status collection of ideas: no specification draft submitted at the moment browser support google chrome microsoft edge opera browser firefox safari not supported not supported not supported not supported not supported data source: is houdini ready yet? worklets before moving onto the other apis, it’s important to explain the worklets concept. worklets are scripts that run during render and are independent of the main javascript environment. they are an extension point for rendering engines. they are designed for parallelism (with 2 or more instances) and thread-agnostic, have reduced access to the global scope and are called by the rendering engine when needed. worklets can be run only on https (on production environment) or on localhost (for development purposes). houdini introduces following worklets to extend the browser render engine: paint worklet - paint api animation worklet - animation api layout worklet - layout api paint api the paint api allows developers to use javascript functions to draw directly into an element’s background, border, or content using 2d rendering context, which is a subset of the html5 canvas api. paint api uses paint worklet to draw an image that dynamically responds to changes in css (changes in css variables, for example). anyone familiar with canvas api will feel right at home with houdini’s paint api. there are several steps required in defining a paint worklet: write and register a paint worklet using the registerpaint function call the worklet in html file or main javascript file using css.paintworklet.addmodule function use the paint() function in css with a worklet name and optional input arguments. let’s take a look at the registerpaint function which is used to register a paint worklet and define its functionality. registerpaint("paintworketexample", class {
  static get inputproperties() { return ["--myvariable"]; }
  static get inputarguments() { return ["<color>"]; }
  static get contextoptions() { return {alpha: true}; }

  paint(ctx, size, properties, args) {
    /* ... */
  }
});
 the registerpaint function consists of several parts: inputproperties: an array of css custom properties that the worklet will keep track of. this array represents dependencies of a paint worklet. inputarguments: an array of input arguments that can be passed from paint function from inside the css. contextoptions: allow or disallow opacity for colors. if set to false, all colors will be displayed with full opacity. paint: the main function that provides the following arguments: ctx: 2d drawing context, almost identical to canvas api’s 2d drawing context. size: an object containing the width and height of the element. values are determined by the layout rendering process. canvas size is the same as the actual size of the element. properties: input variables defined in inputproperties args: an array of input arguments passed in paint function in css after the worklet has been registered, it needs to be invoked in the html file by simply providing a path to the file. css.paintworklet.addmodule("path/to/worklet/file.js");
 any worklet can also be added from an external url (from a content delivery network, for example) which makes them modular and reusable. css.paintworklet.addmodule("https://url/to/worklet/file.js");
 after the worklet has been called, it can be used inside css using the paint function. this function accepts the worklet’s registered name as a first input argument and each input argument that follows it is a custom argument that can be passed to a worklet (defined inside worklet’s inputarguments ). from that point, the browser determines when to call the worklet and which user actions and css custom properties value change to respond to. .exampleelement {
  /* paintworkletexample - name of the worklet
     blue - argument passed to a worklet */
  background-image: paint(paintworketexample, blue);
}
 example the following example showcases paint api and general worklet reusability and modularity. it’s using the ripple worklet directly from google chrome labs repository and runs on a different element with different styles. complete source code is available on the example repository. ripple effect example (uses ripple worklet by google chrome labs) (large preview) feature detection if ("paintworklet" in css) {
  /* ... */
}


@supports(background:paint(paintworketexample)){
  /* ... */
}
 w3c specification status candidate recommendation: stable working draft ready for implementation browser support google chrome microsoft edge opera browser firefox safari supported supported supported not supported not supported data source: is houdini ready yet? animation api the animation api extends web animations with options to listen to various events (scroll, hover, click, etc.) and improves performance by running animations on their own dedicated thread using an animation worklet. it allows for user action to control the flow of animation that runs in a performant, non-blocking way. like any worklet, animation worklet needs to be registered first. registeranimator("animationworkletexample", class {
  constructor(options) {
    /* ... */
  }
  animate(currenttime, effect) {
    /* ... */
  }
});
 this class consists of two functions: constructor: called when a new instance is created. used for general setup. animate: the main function that contains the animation logic. provides the following input arguments: currenttime: the current time value from the defined timeline effect: an array of effects that this animation uses after the animation worklet has been registered, it needs to be included in the main javascript file, animation (element, keyframes, options) needs to be defined and animation is instantiated with the selected timeline. timeline concepts and web animation basics will be explained in the next section. /* include animation worklet */
await css.animationworklet.addmodule("path/to/worklet/file.js");;

/* select element that's going to be animated */
const elementexample = document.getelementbyid("elementexample");

/* define animation (effect) */
const effectexample = new keyframeeffect(
  elementexample,  /* selected element that's going to be animated */
  [ /* ... */ ],   /* animation keyframes */
  { /* ... */ },   /* animation options - duration, delay, iterations, etc. */
);

/* create new workletanimation instance and run it */
new workletanimation(
  "animationworkletexample"  /* worklet name */
  effectexample,             /* animation (effect) timeline */
  document.timeline,         /* input timeline */
  {},                        /* options passed to constructor */
).play();                    /* play animation */
 timeline mapping web animation is based on timelines and mapping of the current time to a timeline of an effect’s local time. for example, let’s take a look at a repeating linear animation with 3 keyframes (start, middle, last) that runs 1 second after a page is loaded (delay) and with a 4-second duration. effect timeline from the example would look like this (with the 4-second duration with no delay): effect timeline (4s duration) keyframe 0ms first keyframe - animation starts 2000ms middle keyframe - animation in progress 4000ms last keyframe - animation ends or resets to first keyframe in order to better understand effect.localtime, by setting its value to 3000ms (taking into account 1000ms delay), resulting animation is going to be locked to a middle keyframe in effect timeline (1000ms delay + 2000ms for a middle keyframe). the same effect is going to happen by setting the value to 7000ms and 11000ms because the animation repeats in 4000ms interval (animation duration). animate(currenttime, effect) {
  effect.localtime = 3000; // 1000ms delay + 2000ms middle keyframe
}
 no animation happens when having a constant effect.localtime value because animation is locked in a specific keyframe. in order to properly animate an element, its effect.localtime needs to be dynamic. it’s required for the value to be a function that depends on the currenttime input argument or some other variable. the following code shows a functional representation of 1:1 (linear function) mapping of a timeline to effect local time. animate(currenttime, effect) {
  effect.localtime = currenttime; // y = x linear function
}
 timeline (document.timeline) mapped effect local time keyframe starttime + 0ms (elapsed time) starttime + 0ms first starttime + 1000ms (elapsed time) starttime + 1000ms (delay) + 0ms first starttime + 3000ms (elapsed time) starttime + 1000ms (delay) + 2000ms middle starttime + 5000ms (elapsed time) starttime + 1000ms (delay) + 4000ms last / first starttime + 7000ms (elapsed time) starttime + 1000ms (delay) + 6000ms middle starttime + 9000ms (elapsed time) starttime + 1000ms (delay) + 8000ms last / first timeline isn’t restricted to 1:1 mapping to effect’s local time. animation api allows developers to manipulate the timeline mapping in animate function by using standard javascript functions to create complex timelines. animation also doesn’t have to behave the same in each iteration (if animation is repeated). animation doesn’t have to depend on the document’s timeline which only starts counting milliseconds from the moment it’s loaded. user actions like scroll events can be used as a timeline for animation by using a scrolltimeline object. for example, an animation can start when a user has scrolled to 200 pixels and can end when a user has scrolled to 800 pixels on a screen. const scrolltimelineexample = new scrolltimeline({
  scrollsource: scrollelement,  /* dom element whose scrolling action is being tracked */
  orientation: "vertical",      /* scroll direction */
  startscrolloffset: "200px",   /* beginning of the scroll timeline */
  endscrolloffset: "800px",    /* ending of the scroll timeline */
  timerange: 1200,              /* time duration to be mapped to scroll values*/
  fill: "forwards"              /* animation fill mode */
});

...
 the animation will automatically adapt to user scroll speed and remain smooth and responsive. since animation worklets are running off the main thread and are connected to a browser’s rending engine, animation that depends on user scroll can run smoothly and be very performant. example the following example showcases how a non-linear timeline implementation. it uses modified gaussian function and applies translation and rotation animation with the same timeline. complete source code is available on the example repository. animation created with animation api which is using modified gaussian function time mapping (large preview) feature detection if (css.animationworklet) {
  /* ... */
}
 w3c specification status first public working draft: ready for community review, prone to specification change browser support google chrome microsoft edge opera browser firefox safari partial support (*) partial support (*) partial support (*) not supported not supported * supported with “experimental web platform features” flag enabled. data source: is houdini ready yet? layout api the layout api allows developers to extend the browser’s layout rendering process by defining new layout modes that can be used in display css property. layout api introduces new concepts, is very complex and offers a lot of options for developing custom layout algorithms. similarly to other worklets, the layout worklet needs to be registered and defined first. registerlayout('examplelayout', class {
  static get inputproperties() { return ['--examplevariable']; }

  static get childreninputproperties() { return ['--examplechildvariable']; }

  static get layoutoptions() {
    return {
      childdisplay: 'normal',
      sizing: 'block-like'
    };
  }

  intrinsicsizes(children, edges, stylemap) {
    /* ... */
  }

  layout(children, edges, constraints, stylemap, breaktoken) {
    /* ... */
  }
});
 worklet register contains the following methods: inputproperties: an array of css custom properties that the worklet will keep track of that belongs to a parent layout element, i.e. the element that calls this layout. this array represents dependencies of a layout worklet. childreninputproperties: an array of css custom properties that the worklet will keep track of that belong to child elements of a parent layout element, i.e. the children of the elements that set this layout. layoutoptions: defines the following layout properties: childdisplay: can have a pre-defined value of block or normal. determines if the boxes will be displayed as blocks or inline. sizing: can have a pre-defined value of block-like or manual. it tells the browser to either pre-calculate the size or not to pre-calculate (unless a size is explicitly set), respectively. intrinsicsizes: defines how a box or its content fits into a layout context. children: child elements of a parent layout element, i.e. the children of the element that call this layout. edges: layout edges of a box stylemap: typed om styles of a box layout: the main function that performs a layout. children: child elements of a parent layout element, i.e. the children of the element that call this layout. edges: layout edges of a box constraints: constraints of a parent layout stylemap: typed om styles of a box breaktoken: break token used to resume a layout in case of pagination or printing. like in the case of a paint api, the browser rendering engine determines when the paint worklet is being called. it only needs to be added to an html or main javascript file. css.layoutworklet.addmodule('path/to/worklet/file.js');
 and, finally, it needs to be referenced in a css file .exampleelement {
  display: layout(examplelayout);
}
 how layout api performs layout in the previous example, examplelayout has been defined using the layout api. .exampleelement {
  display: layout(examplelayout);
}
 this element is called a parent layout that is enclosed with layout edges which consists of paddings, borders and scroll bars. parent layout consists of child elements which are called current layouts. current layouts are the actual target elements whose layout can be customized using the layout api. for example, when using display: flex; on an element, its children are being repositioned to form the flex layout. this is similar to what is being done with the layout api. each current layout consists of child layout which is a layout algorithm for the layoutchild (element, ::before and ::after pseudo-elements) and layoutchild is a css generated box that only contains style data (no layout data). layoutchild elements are automatically created by browser rendering engine on style step. layout child can generate a fragment which actually performs layout render actions. example similarly to the paint api example, this example is importing a masonry layout worklet directly from google chrome labs repository, but in this example, it’s used with image content instead of text. complete source code is available on the example repository. masonry layout example (uses masonry worklet by google chrome labs (large preview) feature detection if (css.layoutworklet) {
  /* ... */
}
 w3c specification status first public working draft: ready for community review, prone to specification change browser support google chrome microsoft edge opera browser firefox safari partial support (*) partial support (*) partial support (*) not supported not supported * supported with “experimental web platform features” flag enabled. data source: is houdini ready yet? houdini and progressive enhancement even though css houdini doesn’t have optimal browser support yet, it can be used today with progressive enhancement in mind. if you are unfamiliar with progressive enhancement, it would be worth to check out this handy article which explains it really well. if you decide on implementing houdini in your project today, there are few things to keep in mind: use feature detection to prevent errors. each houdini api and worklet offers a simple way of checking if it’s available in the browser. use feature detection to apply houdini enhancements only to browsers that support it and avoid errors. use it for presentation and visual enhancement only. users that are browsing a website on a browser that doesn’t yet support houdini should have access to the content and core functionality of the website. user experience and the content presentation shouldn’t depend on houdini features and should have a reliable fallback. make use of a standard css fallback. for example, regular css custom properties can be used as a fallback for styles defined using custom properties & values api. focus on developing a performant and reliable website user experience first and then use houdini features for decorative purposes as a progressive enhancement. conclusion houdini apis will finally enable developers to keep the javascript code used for style manipulation and decoration closer to the browser’s rendering pipeline, resulting in better performance and stability. by allowing developers to hook into the browser rendering process, they will be able to develop various css polyfills that can be easily shared, implemented and, potentially, added to css specification itself. houdini will also make developers and designers less constrained by the css limitations when working on styling, layouts, and animations, resulting in new delightful web experiences. css houdini features can be added to projects today, but strictly with progressive enhancement in mind. this will enable browsers that do not support houdini features to render the website without errors and offer optimal user experience. it’s going to be exciting to watch what the developer community will come up with as houdini gains traction and better browser support. here are some awesome examples of houdini api experiments from the community: css houdini experiments interactive introduction to css houdini houdini samples by google chrome labs references w3c houdini specification drafts state of houdini (chrome dev summit 2018) houdini’s animation worklet - google developers interactive introduction to css houdini (ra, il) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top