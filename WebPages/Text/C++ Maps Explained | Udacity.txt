home nanodegree catalog my classroom '; school of programming c++ maps explained by stephen welch march 19, 2020 last updated on march 19, 2020 start learning looking to learn more about maps in c++ and how to use them? then this article is for you. we cover the details on how exactly to use maps, present some use cases for them and explain when to avoid them entirely. let’s dive in. what is a map in c++? a c++ map is a way to store a key-value pair. a map can be declared as follows: #include <iostream>
#include <map>

map<int, int> sample_map; each map entry consists of a pair: a key and a value. in this case, both the key and the value are defined as integers, but you can use other types as well: strings, vectors, types you define yourself, and more. c++ map use cases there are two main reasons why the map type can be valuable to c++ developers. first, a map allows fast access to the value using the key. this property is useful when building any kind of index or reference. second, the map ensures that a key is unique across the entire data structure, which is an excellent technique for avoiding duplication of data. by virtue of these two advantages, a map is a common choice if you’re developing, for instance, a trading application in which you need to store stock prices by ticker symbol. if you’re creating a weather application, a map would be an effective way to save and look up the current temperature in a set of cities around the world. in an e-commerce store, you’ll likely need a map to find products by identifiers or categories. how do i use a map in c++? the primary operations you’ll perform with a map are creating a new map, adding elements to and reading elements from a map, and iterating through every element in a map. let’s take a look at each of these actions. constructing a map there are five ways to construct a map in c++, but two of them are much more commonly used than the others. the first way is to create an empty map, then add elements to it: #include <map>
#include <string>
using namespace std;

int main() {
  map<int, string> sample_map;
  sample_map.insert(pair<int, string>(1, "one"));
  sample_map.insert(pair<int, string>(2, "two"));

  cout << sample_map[1] << " " << sample_map[2] << endl;
} in this example, we create a map that uses integers as keys and strings as values. we use the pair construct to create a key-value pair on the fly and insert that into our map. the second often-used option is to initialize the map to a list of values at declaration. this option has been available since the c++11 standard and therefore isn’t supported by older compilers, but it allows for clearer declaration: #include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
  map<int, string> sample_map { { 1, "one"}, { 2, "two" } };

  cout << sample_map[1] << " " << sample_map[2] << endl;
} other ways to create a map include copying an existing map, copying parts of an existing map (by indicating a start position and an end position for the copy) and moving elements from another map without creating an intermediate copy. accessing map elements in order to access the elements of the map, you can use array-style square brackets syntax: ...
cout << sample_map[1] << endl;
... another option, available as of c++11, is the at method: ...
cout << sample_map.at(1) << endl;
... inserting elements when inserting elements into a map, it’s common to use either the square brackets syntax or the insert method: ...
sample_map.insert(pair<int, string>(4, "four");
sample.map[5] = "five";
... iterating through elements in some cases, you might need to walk through a map and retrieve all the values in it. you can do this by using an iterator—a pointer that facilitates sequential access to a map’s elements. an iterator is bound to the shape of the map, so when creating an iterator you’ll need to specify which kind of map the iterator is for. once you have an iterator, you can use it to access both keys and values in a map. here’s what the code would look like: int main() {
  map<int, string> sample_map { { 1, "one"}, { 2, "two" } };
  sample_map[3] = "three";
  sample_map.insert({ 4, "four" });

  map<int, string>::iterator it;
  for (it = sample_map.begin(); it != sample_map.end(); it++) {
    cout << it->second << " ";
  }
  cout << endl;
} in this example, the map contains pairs of <int, string>, so we create an iterator that matches that format. we use the sample_map.begin() method to point the iterator to where it should start, and indicate that the for loop should stop when we reach the sample_map.end() location—the end of the map. the iterator provides an it->first function to access the first element in a key-value pair (the key), and then it->second can be used to access the value. so, using the example above, we would print out only the values from our sample map. when not to use a c++ map the map in c++ is a great fit for quickly looking up values by key. however, searching the contents of a map by value requires iterating through an entire map. if you want to be able to find values in a map, iterating through it can be slow as a map gets large. the boost library offers a bi-directional map which performs better when searching for values often. this data structure isn’t included in the standard c++ library, so you’ll need to install the boost library on each machine where you compile or run your program (dynamic linking), or alternatively include the boost library inside your executable (static linking). if you find yourself needing to search a map by value in a relatively simple program, it may be that a map is the wrong object to use. consider using a c++ vector, queue, stack or other data structure which might end up making the program more straightforward and more efficient. does order matter in c++ maps? to demonstrate whether order is important in c++ maps, we’ve slightly modified the above example to insert the element { 4, “four” } before inserting { 3, “three” }: #include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
  map<int, string> sample_map { { 1, "one"}, { 2, "two" } };
  sample_map.insert({ 4, "four" });
  sample_map[3] = "three";

  map<int, string>::iterator it;
  for (it = sample_map.begin(); it != sample_map.end(); it++) {
    cout << it->second << " ";
  }
  cout << endl;
} when we run the program, the output is still the same as before, even though the order in which we add elements has changed! $ ./map.x
one two three four this is because maps in c++ keep their elements ordered by key. also, in c++ a map can’t contain duplicate items, so using a map is a way to simultaneously deduplicate and order a set of elements. if you don’t care about the order of elements in a map, consider using an unordered_map element, which is faster at adding and accessing elements than a regular map. can i store a map in a map? you definitely can! just make sure that the format of the map reflects your intentions: #include <iostream>
#include <map>
#include <string>
using namespace std;

int main() {
  map<int, map<int, string> > nested_map;
  nested_map[1][1] = "one";
  cout << nested_map[1][1] << endl;
} in this example, the inner map object acts as a value in the outer map. further reading and resources if you’d like to see the list of all available methods for a map object, check out the map reference. if you’re looking for more examples of map usage, consider reading the c++ map tutorial usage guide. conclusion in this article, we walked you through what a c++ map is and how to use one. we showed you a few examples of adding elements, reading them and traversing the map. would you like to learn more about c++? sign up for our c++ nanodegree program. start learning click below to download your preferred career guide web developer career guide cloud career guide data career guide robotics career guide advance your career enter your email below to download one of our free career guides country codeunited states - 1canada - 1india - 91albania - 355algeria - 213american samoa - 1-684anguilla - 1-264antarctica - 672antigua and barbuda - 1-268argentina - 54armenia - 374aruba - 297australia - 61austria - 43azerbaijan - 994bahamas - 1-242bahrain - 973bangladesh - 880barbados - 1-246belarus - 375belgium - 32belize - 501bermuda - 1-441bhutan - 975bolivia - 591bosnia and herzegovina - 387botswana - 267brazil - 55british indian ocean territory - 246british virgin islands - 1-284brunei - 673bulgaria - 359burundi - 257cambodia - 855cameroon - 237canada - 1cape verde - 238cayman islands - 1-345central african republic - 236chile - 56china - 86colombia - 57costa rica - 506croatia - 385curacao - 599cyprus - 357czech republic - 420democratic republic of the congo - 243denmark - 45dominica - 1-767dominican republic - 1-809, 1-829, 1-849ecuador - 593egypt - 20el salvador - 503equatorial guinea - 240estonia - 372ethiopia - 251falkland islands - 500faroe islands - 298fiji - 679finland - 358france - 33french polynesia - 689georgia - 995germany - 49ghana - 233gibraltar - 350greece - 30greenland - 299grenada - 1-473guam - 1-671guatemala - 502guinea - 224haiti - 509honduras - 504hong kong - 852hungary - 36iceland - 354india - 91indonesia - 62iraq - 964ireland - 353isle of man - 44-1624israel - 972italy - 39ivory coast - 225jamaica - 1-876japan - 81jordan - 962kazakhstan - 7kenya - 254kosovo - 383kuwait - 965kyrgyzstan - 996latvia - 371lebanon - 961lesotho - 266liberia - 231libya - 218liechtenstein - 423lithuania - 370luxembourg - 352macau - 853macedonia - 389madagascar - 261malawi - 265malaysia - 60maldives - 960mali - 223malta - 356marshall islands - 692mayotte - 262mexico - 52moldova - 373monaco - 377mongolia - 976montenegro - 382morocco - 212mozambique - 258myanmar - 95namibia - 264nauru - 674nepal - 977netherlands - 31netherlands antilles - 599new caledonia - 687new zealand - 64nicaragua - 505niger - 227nigeria - 234northern mariana islands - 1-670norway - 47pakistan - 92palestine - 970panama - 507papua new guinea - 675paraguay - 595peru - 51philippines - 63poland - 48portugal - 351puerto rico - 1-787, 1-939qatar - 974romania - 40russia - 7rwanda - 250saint lucia - 1-758saint martin - 590saint vincent and the grenadines - 1-784san marino - 378saudi arabia - 966serbia - 381sierra leone - 232singapore - 65slovakia - 421slovenia - 386solomon islands - 677south africa - 27south korea - 82spain - 34sri lanka - 94sudan - 249swaziland - 268sweden - 46switzerland - 41taiwan - 886tanzania - 255thailand - 66trinidad and tobago - 1-868tunisia - 216turkey - 90turkmenistan - 993turks and caicos islands - 1-649u.s. virgin islands - 1-340uganda - 256ukraine - 380united arab emirites - 971united kingdom - 44united states - 1uruguay - 598uzbekistan - 998vatican - 379venezuela - 58vietnam - 84zimbabwe - 263other i agree i consent and agree to receive email marketing communications from udacity. choose your guide you have successfully subscribed! by entering your information above and clicking “choose your guide”, you consent to receive marketing communications from udacity, which may include email messages, autodialed texts and phone calls about udacity products or services at the email and mobile number provided above. udacity or its providers typically send a max of [5] messages per month. message and data rates may apply. you understand that consent is not a condition of purchase. you may reply stop at any time to cancel, and help for help. read the full terms of use and our privacy policy, or learn more about udacity sms on our faq. categories announcements artificial intelligence career guidance digital transformation featured blogs free courses hiring and recruiting instructors learning and motivation mentor stories product management scholarships school of ai school of autonomous systems school of business school of cloud computing school of data science school of programming self driving car student success tech tips tech trends and your company udacity for enterprise uncategorized workforce planning and management workforce transformation popular nanodegree programs c++ data engineer ai product manager full stack web developer ux designer programming for data science with python latest posts product management methodologies: agile vs waterfall vs scrum vs kanban udacity leads effort to upskill laid-off workers with new scholarship udacity’s contribution to the covid-19 crisis: one free month access to nanodegree programs 10 nanodegree programs later… a dream job | student story c++ maps explained stephen welch stephen is a content developer at udacity and has built the c++ and self-driving car engineer nanodegree programs. he started teaching and coding while completing a ph.d. in mathematics, and has been passionate about engineering education ever since. other posts by stephen welch posts by stephen microsoft visual c++ review c++ compilers explained share this post twitter facebook linkedin previous post ← top trends in product management to watch next post 10 nanodegree programs later… a dream job | student story → popular nanodegree programs vr developer self-driving car engineer data analyst ios developer front-end web developer machine learning engineer android developer student resources blog career resource center help & faq catalog veteran programs mobile scholarships hiring partners udacity about in the news jobs @ udacity georgia tech udacity for business hire graduates student success inquiries contact us legal service status site map nanodegree is a trademark of udacity. © 2011-2020 udacity, inc. × subscribe to our newsletter learning = growing sign up for udacity blog updates to get the latest in guidance and inspiration as you discover programming, web development, data science, and more. submit