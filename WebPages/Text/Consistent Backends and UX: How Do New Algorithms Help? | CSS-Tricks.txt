skip to main content css-tricks articles videos almanac snippets newsletter jobs guides back to top contact about archives advertise jobs license subscribe forums guest posting facebook twitter youtube instagram rss search for: search open search open navigation home / articles / consistent backends and ux: how do new algorithms help? author brecht de rooms comments start conversation last updated mar 27, 2020 personalized marketing with mailchimp article series why should you care? what can go wrong? what are the barriers to adoption? how do new algorithms help? in previous articles, we explained what consistency is, the difference between "strong" and "eventual" consistency, and why this distinction is more important than ever to modern application developers. we also introduced the notion of ‚Äòconsistency tax‚Äô: the extra time and effort that a development team needs to invest if they choose a system with only eventual consistency or limited consistency guarantees. several modern databases use state-of-the-art algorithms to eliminate the tradeoff between consistency and performance. of course, we would not want you to take our word for it without a proper explanation. therefore, in this final article, we dive into the technical details behind some of these databases. typically, the only source of information for these technical details are research papers, so the point of this article is to explain these systems in simpler terms. because these systems are far more complex in reality, we‚Äôll provide the links in the text in case you want to know more and love to read research papers. introduction in parts 1 and 2 of this article series, we explained how distributed databases use different replicas to spread the load and/or serve users in different regions. to summarize here, for new readers, a replica is just a duplication of your data. and this duplication can live either in the same location for redundancy, or in another location to offer lower latencies to users in those locations. having multiple replicas that can handle both reads and writes has a strong advantage, because the database becomes scalable and can offer lower latency to all your users, no matter where they are. however, you do not want each of the replicas to have their own interpretation of the data. instead of small data differences between each replica, you want one unique interpretation of the data, which is often referred to as a single source of truth. in order to achieve that, you need to have some sort of agreement on data changes. we need a consensus. waiting for consensus every distributed database that aims to be consistent has multiple replicas that have to agree on the outcome of transactions. if conflicting data updates happen these replicas have to agree which update goes through and which doesn‚Äôt. this is called ‚Äúconsensus.‚Äù let‚Äôs go back to our game to exemplify why we need consensus. imagine that the player of our game only has 3 gold pieces left, but tries to simultaneously buy two different items from two different shops for a total budget larger than the remaining 3 gold pieces. this involves two transactions, one for each item/shop, which we denote as t1 and t2. and let's pretend that the owners of the shops are across the globe from each other, so the transactions take place on two different replicas. if both of the transactions are accepted the user would be able to buy more than he can afford. how do we prevent the user from overspending? an example of two replicas that each receive a transaction (t1) and (t2). if we let both go through it would violate our business rule that users can‚Äôt spend more than they own. clearly these replicas need decide which transaction is allowed and which should be blocked. we know that these replicas need to communicate in order to agree on the final outcome of the two transactions. what we don‚Äôt know is how much communication they need. how many messages have to go back and forth between replica 1 and replica 2 in order to agree which transaction gets priority and which one gets cancelled? as replicas in a distributed database are meant to serve users from different regions in the world with low latency, they are far apart by nature. by placing duplicates of the data closer to the end users, these users can read with lower latencies. however, when writes happen, the replicas need to send messages to each other to update all duplicated data uniformly--and these messages can take several 10s of milliseconds because they're bridled by the speed of light as they travel across the globe. it‚Äôs clear that we need to keep the number of cross-data center messages as small as possible so that the end user isn't left waiting around for these replicas across the globe to come to consensus. for a long time, it had been thought to be impossible or impractical to do this. but today, several technologies exist to keep the number of round-trips low and bring latency within normal bounds. the distance between new york and paris is 5,839 km. for light to travel from new york to paris and then back again would take 40 milliseconds. ‚Äî theoretical vs real-world speed if it takes a minimum of 40 milliseconds to travel between new york and paris, a round-trip would take at least 80ms. the most important question that remains is: ‚Äúhow many round-trips do we need to execute transactions?‚Äù the answer to this question depends largely on the algorithms that are used. how to reach agreement? it appears that in order to achieve consensus about something, you need at least four hops (or two rounds of communication): one round to let each replica know that you are about to do something, then a second round to actually execute the action once everyone agrees that this action can be executed. this is something called distributed two-phase commit which is used by almost any distributed database. let‚Äôs look at an analogy. imagine you have to agree with a group of people on a good date for a party. it might go like this: first, polly asks everyone if they can make it to a party on monday; she now knows that everyone can actually come to the party. next, she needs to let everyone know that the party will indeed be on monday, and people acknowledge that they will be there. these are very similar to the two phases in two-phase commit. of course, databases don‚Äôt party so the phases have different functions. in the case of a distributed system, the phases are called: prepare or request to commit: make sure that everyone knows about the transaction. in this phase, replicas in a distributed database store the query in some kind of todo list (a transaction log) on the disk to make sure they still know what to do if the server goes down. commit: actually calculate the results and store them of course, as always, it‚Äôs never that simple. there are many flavors of such algorithms. for example, there are improvements of two-phase commits called paxos and raft and even many variants of these (multi paxos/fast paxos/...). these alternatives aim to improve issues of availability or performance. to understand the availability issues, simply imagine that polly falls sick or amber‚Äôs phone dies. in the former case, she would be unable to continue her work as party coordinator and in the latter case, it would temporarily be impossible for polly to know whether amber agrees on the party date. raft and paxos improve on this by only requiring the majority to answer and/or selecting a new coordinator automatically when the leader or coordinator goes down. a good animation that shows how raft works can be found here. agree about what? can we conclude that each distributed database then requires 2 round trips to write/read data? no, the reality is more complex than that. on one side, there are many possible optimizations and on the other side, there might be multiple things we need to agree on. agree on the time of a transaction agree whether reads can be executed the simplest example that has multiple two-phase commit rounds is probably cassandra‚Äôs light-weight transactions. they first require consensus agreements on reads and then consensus on writes. if each message takes 40ms to travel, this means the entire transaction requires 320ms or longer--depending on the required "locks" as we‚Äôll explain later. this is fairly easy to understand, but there are some issues with the implementation since cassandra was never designed to be strongly consistent. does that mean that strongly consistent databases are even slower? not at all! modern distributed databases use a mix of interesting features to achieve better performance. waiting for locks not only do we need to wait for messages to come to an agreement, but almost every distributed database will also use "locks". locks guarantee that the data about to be altered by a transaction is not being simultaneously altered by another transaction. when data is locked, it can‚Äôt be altered by other transactions, which means that these transactions have to wait. the duration of such a lock, therefore, has a big impact on performance. again, this performance impact depends on the algorithm and optimizations that were implemented by the database. some databases hold locks longer than others and some databases do not use locks at all. now that we know enough basics, let's dive into the algorithms. modern algorithms for consensus we now know that consensus and locks are the main bottlenecks that we need to optimize. so let‚Äôs go back to the main question of this article: ‚Äúhow does new technology lower these latencies within acceptable bounds?‚Äù let‚Äôs start off with the first of these modern algorithms, which sparked interesting ideas for the rest of the database world. 2010 - percolator percolator is an internal system built upon bigtable (one of the early nosql databases built by google) that google used to make incremental updates to their search index's page crawling speed. the first paper on percolator was released in 2010, inspiring the first distributed database inspired by it: foundationdb in 2013. foundationdb then got acquired by apple to finally release a stable version in 2019, together with the release of a foundationdb paper. although percolator allowed google to speed up page crawling significantly, it was not originally built as a general-purpose database. it was rather intended to be a fast and scalable incremental processing engine to support google's search index. since the search index had to be scalable, many calculations had to happen on many machines concurrently, which required a distributed database. as we learned in the previous articles, programming against distributed systems that store data can be very complex, and traditionally required that developers pay a 'consistency tax' to program around unpredictable database behavior. to avoid paying so high a consistency tax, google adopted a strong consistency model when they built percolator. the consistency model of percolator could not exist without two key ingredients: versioning, and the timestamp oracle ingredient 1: versioning as we mentioned in previous articles, strong consistency requires us to agree on a global order for our transactions. versioning is one of the elements that will be crucial to many of these algorithms since it can be used for failure recovery, to help replicate data, and to support a consistency model called ‚Äòsnapshot isolation‚Äô. versioning helps in failure recovery when a node fails or gets disconnected. when the node comes back online, thanks to the versions, it can easily restore its state by starting at the last snapshot that it was able to save, and then replaying the transactions based on the versions in another node. all it has to do is ask another node: ‚Äúhey, what has changed since i was gone?‚Äù without versioning, it would have to copy over all the data, which would have put a huge strain on the system. failure recovery is great, but the strongest advantage lies in the fact that such a versioning system can be used to implement a strong consistency model. if the versioning system keeps versions for each data change, we can actually go back in time and do queries against an earlier version of our data. some bright minds found out that this historical querying capability could be used to provide a consistency model called ‚Äòsnapshot consistency‚Äô. the idea of snapshot consistency is to pick a version of the data at the beginning of the query, work with that version of the data during the rest of the query, then write a new version at the end of the query. there is one possible pitfall here: during the execution of such a query, another query could be writing data that conflicts with the first query. for example, if two write queries start with the same snapshot of a bank account with $1000 on it, they could both spend the money since they do not see the writes of the other query. to prevent that, an additional transaction will take place to see if the snapshot's values changed before either query writes a result. if something conflicting did happen to change the snapshot's value, the transaction is rolled back and has to be restarted. however, there is still one problem percolator needs to solve. clocks on different machines can easily drift apart a few 100s of milliseconds. if data for a query is split over multiple machines such as in our initial example, you can‚Äôt simply ask both machines to give you data at a certain timestamp since they have a slightly different idea of what the current time is. it‚Äôs a matter of milliseconds, but when many transactions have to be processed, a few milliseconds are all it takes to go from correct data to faulty data. time synchronization brings us to the second percolator ingredient. ingredient 2: the timestamp oracle percolator‚Äôs solution to the time synchronization problem is something called the timestamp oracle. instead of letting each node dictate its own time (which was not accurate enough), percolator uses a central system that exposes an api providing you with a timestamp. the node on which this system lives is the timestamp oracle. when we keep multiple versions of our data, we need at least two timestamps for each query. first, we need a timestamp to query a snapshot, which we will use to read data. then, at the end of the transaction when we are ready to write, we need a second timestamp to tag the new data version. as a result, percolator has the disadvantage that it needs at least two calls to the timestamp oracle, which introduces even more latency if the oracle is in another region from the nodes where the calls originated. when google came up with their distributed database spanner, they solved this problem. 2012 - spanner spanner was the first globally distributed database to offer strong consistency, which essentially means that you get low latency reads without having to worry about potential database errors anymore. developers no longer need to invest extra work to circumvent potential bugs caused by eventual consistency. the paper was released in 2012 and it was released to the general public in 2017 as spanner cloud. ingredient 1: versioning google built spanner after their experience with percolator. since percolator's versioning system proved to work, they kept this in spanner's design. this versioning system provided the ability to do very fast reads (snapshot reads) if you were willing to give up consistency. in that case, you could run queries and give spanner a maximum age of the results. for example: ‚Äúplease return my current inventory as fast as possible, but the data can only be 15 seconds old‚Äù. basically, instead of abandoning consistency, you could now choose for each query which consistency level suited your use-case. ingredient 2: truetime to eliminate the extra overhead to synchronize time between machines, spanner abandoned the timestamp oracle in favor of a new concept called truetime. instead of having one central system that provides a unified view of time, truetime tries to reduce the clock drift between the machines themselves. engineers at google managed to limit local clock drift by implementing a time synchronization protocol based on gps and atomic clocks. this synchronization algorithm allowed them to limit clock drift within a boundary of 7ms, but required specific hardware that consisted of a combination of gps and atomic clock technology. of course, there is still a potential clock drift of 7ms, which means that two servers could still interpret a timestamp to be two different snapshots. this is solved by the third ingredient for spanner: commit-wait. ingredient 3: commit-wait in fact, the truetime api does not return one timestamp but returns and interval n which it is sure that the current timestamp should lie. once it is ready to commit, it will just wait a few milliseconds to cope with the potential drift which is called ‚Äòcommit-wait‚Äô. this makes sure that the timestamp that will be assigned to the write is a timestamp that has passed on all nodes. it‚Äôs also the reason that running spanner on commodity hardware can not deliver the same guarantee since the wait period would need to be a few 100s of milliseconds. 2012 - calvin the first paper on the calvin algorithm was released in 2012, from research at yale. just like the previous approaches, calvin consists of several ingredients. although versioning is also part of it, the rest of the approach is radically different which requires a few extra ingredients to work: deterministic calculations, and the separation of ordering from locking. these are ingredients that are typically not found in databases with traditional architecture. by changing the architecture and accepting that queries have to be deterministic, calvin can reduce the worst-case number of cross- datacenter messages to two. this pushes down the worst-case latency of global transactions significantly and brings it below 200ms or theoretically even below 100ms. of course, in order to believe that this is possible, you might want to know how it works first, so let‚Äôs take a look at the algorithm. ingredient 1: versioning similar to percolator and spanner, calvin relies on versioned data. these snapshots in calvin are mainly used to ensure fault-tolerance. each node stores different snapshots which can be considered as checkpoints. a disconnected node that comes back online only needs to grab the timestamp of the last checkpoint it has witnessed, and then ask another node to inform him of all the transactions that came after that checkpoint. ingredient 2: deterministic calculations many front-end developers will have heard of the elm frontend framework which implements a react redux-like workflow. elm has a steeper learning curve than similar javascript-based frameworks because it requires you to learn a new language. however, because the language is functional (no side-effects), elm allows some impressive optimizations. the key is that functions in elm give up destructive manipulations to be deterministic. you can run the same function with the same input twice and it will always yield the same result. because they are deterministic, elm queries can now more efficiently decide how to update views. similar to elm, calvin has given up something to speed up the calculations. in the case of calvin, we can basically say that the result of a transaction will be the same, whether it‚Äôs executed on machine a or machine b. this might seem evident, but typically databases do not guarantee this. remember that sql allows you to use the current time or allows something called interactive transactions where user input can be inserted in the middle of a transaction, both of which could violate the guarantees provided by calvin. to achieve deterministic calculations, calvin (1) needs to take out calculations such as current time and pre-calculate them, and (2) does not allow interactive transactions. interactive transactions are transactions where a user starts a transaction, reads some data, provides some additional user input in the middle, and then finally does some extra calculations and possibly some writes. since the user is not predictable, such a transaction is not deterministic. in essence, calvin trades in a minor convenience (interactive transactions) for great performance. ingredient 3: separate the problem of ordering. databases spend a lot of time negotiating locks in order to make it look like the system is executing in a specific order‚Äù. if an order is all you need, maybe we can separate the problem of locking from the problem of ordering. this means though that your transactions have to be pure. ‚Äî kyle kingsbury separating the concern of ordering transactions from the actual execution has been considered many times in the database world but without much success. however, when your transactions are deterministic, separating the ordering from the calculations actually becomes feasible. in fact, the combination of deterministic calculations and the separation of ordering from the rest of the algorithm is extremely powerful since it helps to reduce lock duration and greatly diminishes the slower communication between distant nodes (cross-datacenter communication). shorter lock duration whenever locks are held on a piece of data, it means that other queries that use that data have to wait. therefore, shorter locking results in better performance. below is an image that shows an overview of the locking procedure in calvin compared to how a traditional distributed database might do it. most databases would keep a lock on data until there is at least a consensus on what to write while calvin would only keep the lock until all nodes agree on the order. because the calculations are deterministic and they all agreed on the order, each node will calculate separately and come to the same end result. less communication between distant nodes besides the advantages in lock duration, separating ordering from the rest of the algorithm also requires less communication. as explained before with the cassandra example, a distributed database typically requires cross-datacenter communication in many phases of their algorithm. in the case of calvin, the only moment we need to agree on something is at the moment we determine the order. with the raft protocol, this could be done in two hops which makes it possible to achieve sub 100ms latencies for read-write queries. together with the reduced lock time, this also brings superb throughput. the original calvin paper has also done experiments that show that this approach significantly outperforms traditional distributed database designs under high contention workloads. their results of half a million transactions per second on a cluster of commodity machines are competitive with the current world record results obtained on much higher-end hardware. run on any hardware besides that, calvin has another advantage: it no longer requires specific hardware in order to obtain such results. since calvin can run on commodity machines, it can run on any cloud provider. 2014 - the faunadb flavor of consensus ingredient 1: versioning faunadb has its own distributed transaction protocol with some similarities to calvin. just like the former approaches, faunadb‚Äôs data is also versioned. since versioning is not only useful for the consistency model but can also have business value, faunadb has upgraded this mechanism to a first-class citizen that can be used by end-users. this feature essentially allows time-traveling queries. end-users can execute a query on historic data to answer questions such as: ‚Äúwhat would the result of this query have been 20 days ago?‚Äù. this is useful to recover data that was accidentally overwritten, audit data changes, or simply incorporate time-travel in your application‚Äôs features. ingredient 2 and 3: deterministic calculations and separation like calvin, faunadb also has deterministic calculations and separates the problem of ordering from the rest of the algorithm. although there are similarities, calculating transactions in faunadb happens in a different phase than calvin. where calvin takes advantage of the deterministic nature to execute the same transaction multiple times once the order is set, faunadb will calculate only once prior to consensus on the order of the transactions. which brings us to the fourth ingredient. ingredient 4: optimistic calculation faunadb adds a fourth ingredient which we have seen already when we talked about snapshot isolation: optimistic calculations instead of locking. faunadb will not lock, but will instead optimistically calculate the result of the transaction once in the node where the transaction was received, and then add the result and the original input values to the log. where calvin would have saved the query that needs to be executed in the transaction log, faunadb will save both the result of the calculation and the original input values in the log. once there is consensus on the order in which the results have to be applied, faunadb will verify whether the input data for that calculation has changed or not (thanks to versioning). if the input values have changed, the transaction is aborted and restarted, if they have remained the same, the results are applied on all nodes without any extra calculation. faunadb‚Äôs algorithm has similar advantages as calvin, but reduces the amount of required calculations in the cluster. conclusion in this series, we have explained how strong consistency can help you build error-free applications more efficiently. in this last article, we have further explained how revolutionary ideas can power a new generation of distributed databases that are both consistent and performant. the takeaway in the previous articles was: ‚Äúconsistency matters‚Äù. in this final article, the takeaway is encompassed in the following: in the near future, if you read a phrase such as: ‚Äúmany nosql databases do not offer atomic writes for multiple documents, and in return give better performance. and while consistency is another great feature of sql databases, it impedes the ability to scale out a database across multiple nodes, so many nosql databases give up consistency.‚Äù - the biggest challenges of moving to nosql realize that modern algorithms enable databases to deliver consistency without centralization. in this article, we have seen a few examples of algorithms and databases that do this. databases that build upon these algorithms are a next generation of databases that no longer can be described by simple categories such as nosql, sql, or even newsql. with distributed cloud databases based on percolator, spanner, calvin, and faunadb‚Äôs transaction protocol, you can have highly performant distributed databases that offer stronger consistency models. this means that you can build data-intensive applications that offer low-latency without having to worry about data errors, performance, or service provisioning. in such systems, consistency is transparent, and you do not have to think about it as a developer. the next time you choose a database, pick one that is consistent by default. article series why should you care? what can go wrong? what are the barriers to adoption? how do new algorithms help? our learning partner need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. leave a reply cancel reply your email address will not be published. required fields are marked * comment name * email * website save my name, email, and website in this browser for the next time i comment. get the css-tricks newsletter notify me of follow-up comments by email. copy and paste this code: micuno * leave this field empty all comments are held for moderation. we'll publish all comments that are on topic, not rude, and adhere to our code of conduct. you'll even get little stars if you do an extra good job. you may write comments in markdown. this is the best way to post any code, inline like `<div>this</div>` or multiline blocks within triple backtick fences (```) with double new lines before and after. want to tell us something privately, like pointing out a typo or stuff like that? contact us. we have a code of conduct. be cool. be helpful. the web is a big place. have fun. high five. related how do you stay up to date in this fast‚Å†-‚Å†moving industry? a good start is to sign up for our weekly hand-written newsletter. we bring you the best articles and ideas from around the web, and what we think about them. email address subscribe facebook @csstricks twitter @css youtube @realcsstricks instagram @real_css_tricks rss feed css-tricks* is created, written by, and maintained by chris coyier and a team of swell people. the tech stack for this site is fairly boring. that's a good thing! i've used wordpress since day one all the way up to v17, a decision i'm very happy with. i also leverage jetpack for extra functionality and local for local development. *may or may not contain any actual "css" or "tricks". other nav contact about guest writing jobs advertise license subscribe all authors codepen codepen is a place to experiment, debug, and show off your html, css, and javascript creations. flywheel logo flywheel css-tricks is hosted by flywheel, the best wordpress hosting in the business, with a local development tool to match. shoptalk is a podcast all about front-end web design and development. css-tricks presents üìÖ upcoming front-end conferences css-tricks presents the power of serverless for front-end developers