skip to main content css-tricks articles videos almanac snippets newsletter jobs guides back to top contact about archives advertise jobs license subscribe forums guest posting facebook twitter youtube instagram rss search for: search open search open navigation home / articles / consistent backends and ux: what are the barriers to adoption? author brecht de rooms comments start conversation last updated mar 26, 2020 personalized marketing with mailchimp article series why should you care? what can go wrong? what are the barriers to adoption? how do new algorithms help? there are very few scenarios in which an eventually consistent database is preferable over a strongly consistent database. further, in a multi-region application scenario where scaling is necessary, choosing either an undistributed database or an eventually consistent database is even more questionable. so what motivates engineers to ignore strongly consistent distributed databases? we have seen many reasons, but wrong assumptions drive most of them. ‚Äúthe cap theorem says it‚Äôs impossible‚Äù as we explained in part 1 of this series, the cap theorem is widely accepted yet often misinterpreted. when many people misinterpret a well-known theorem, it leaves a mark. in this case, many engineers still believe that eventual consistency is a necessary evil. ‚Äúbuilding a strongly consistent distributed database is too hard/impossible‚Äù it is slowly sinking in that consistency should not be sacrificed, yet many databases still put consistency second. why is that? some popular databases offer options that deliver higher consistency, but only at the cost of potentially very high latencies. their sales messaging might even claim that delivering consistency at low latencies in a multi-region distributed database is incredibly hard or even impossible, and the developer audience has salient memories of experiencing very poor latencies in databases that were not built for consistency. combined, they jointly fortify the misconception that strong consistency in a distributed database with relatively low latencies is impossible. ‚Äúpremature optimization is the root of all evil‚Äù many engineers build according to the ‚Äúpremature optimization is the root of all evil‚Äù (donald knuth) principle, but that statement is only meant to apply to small inefficiencies. building your startup on a strongly consistent distributed scalable database might seem like a premature optimization, because initially, your application doesn't require scale and might not require distribution. however, we are not talking about small inefficiencies here. the requirement to scale or distribute might arise overnight when your application becomes popular. at that point, your users have a terrible experience, and you are looking at a substantial challenge to change your infrastructure and code. ‚Äúit‚Äôs hard to program against a distributed database‚Äù this used to have some truth to it since distributed databases were new, and many came with severe limitations. they did not allow joins, only allowed key-value storage, or required you to query your data according to predefined sharding keys, which you couldn't change any more. today, we have distributed databases that have flexible models and provide the flexibility you are used to with traditional databases. this point is very related to the previous point, which ignores that nowadays, starting to programming against a strongly consistent distributed database is just as easy and probably easier in the long run compared to a traditional database. if it's just as easy, then why not optimize from the start? working with an eventually consistent database is like... distributed databases are often created by people who have experienced problems with eventual consistency. for example, faunadb was built by former twitter engineers after having experienced how difficult it is to build a scalable system on top of the eventually consistent databases that were popular around that time, such as cassandra. these problems typically manifest when a new company starts to scale, hence many younger engineers have never experienced them first hand. sometimes painful things can teach us lessons that we didn‚Äôt think we needed to know.‚Äî amy poehler discussing the dangers of eventual consistency typically leads to the "it works for me‚Äù argument from engineers who simply haven‚Äôt experienced any issues yet. since that often takes months (or years, if you are lucky), let's look at an analogy. ‚Ä¶riding a bike with loose wheels. a while ago, my best friend was about to miss an appointment, so i lent him my bike. i was happy that i helped out, he was happy, and everything went well. that happiness quickly turned into pain when he tried to jump the bike onto a side-walk. you see... i had tinkered with the bike earlier that day and had forgotten to tighten the front wheel. he came back with a huge purple bruise. the bike example is very similar to working with a database that is not strongly consistent. everything will go well until you try to lift the bike‚Äôs wheel (or in other words, until your company lifts off and starts scaling up). at the moment your application needs to scale up, you typically do so by replicating services. once the database becomes the bottleneck, you replicate your traditional database or move to a distributed database. sadly, at that point, features in your application might break when you start replicating your database. until now, you hadn't noticed these problems since the database ran on a single node. at that point, two things might happen: situation 1, build around it/fix it: the developers soon realize that the database they are ‚Äòriding‚Äô is unreliable for the features they have built or are trying to build. their choices come down to canceling the features, simplifying the features, or changing the database. situation 2, fail epically: the developers were not well informed by the vendor (i was a lousy bike vendor to my friend) about the risks, and now lack the information to understand the very subtle implications of what's happening. this is not necessarily due to a lack of capability of the engineer. poorly defined standards and optimistic marketing do a great job of obfuscating different databases' consistency guarantees. the developers who end up in the first situation are often already experienced in dealing with eventually consistent systems. they will now either accept that they can't deliver on some features, or will build a complex and hard-to-maintain layer on top of the database to get what they need. in essence, they attempt to develop a strongly consistent database on top of an eventually consistent one. that's a shame since other people have designed distributed databases from the ground up that will not only be more efficient, but don't require maintenance from your development team! ‚Ä¶riding an invisible bike with loose wheels. the developers who end up in the second situation are riding a partly invisible bike. they do not realize that the wheel is loose, do not see the wheel detach, and once they look up after falling, they still see a completely intact bike. at the moment things go wrong, the complexity to resolve these bugs is high for several reasons: determine whether it‚Äôs an eventual consistency bug. the issue might be either an application bug, or a bug caused by misunderstanding the guarantees of the underlying database. to know for sure, we need to investigate the application logic, and in case the application logic is sound in a non-distributed environment, the engineer has to have the instinct to evaluate whether this situation might arise due to eventual consistency. the cause has disappeared. second, since the database eventually becomes consistent, the cause of the problem has probably disappeared (the wheel is magically reattached to the bike, and all you see is an impeccable bike). fix it! once the problem is determined, you can either find a way around it, attempt to build a layer on top of the database (hello latency and other potential bugs), remove the features, or change the database. the last option is sometimes perceived as easy. however, even the most subtle differences between databases make this a very challenging endeavor. at the moment your application is lifting off, you already have your hands full. this is not the moment you want to be swapping databases! ‚Ä¶riding an invisible bike with loose wheels and a group of people standing on your shoulders. the invisible bike example is still too forgiving. in reality, others are probably depending on your application. so basically, you are riding an invisible bike while others (your clients) are standing on your shoulders. not only will you fall, but they will fall with you and land on top of you--heavily and painfully. you might not even survive the fall at that point; in other words, your company might not survive the storm of negative feedback from your clients. the moral of the story? if you had chosen a strongly (vs.eventually) consistent database from the beginning, you would not have to consider going through a complex and resource-intensive project like migrating your database at a point when your clients are already frustrated. conclusion choosing an eventually consistent database for scaling was justified a few years back when there was simply no other choice. however, we now have modern databases that can scale efficiently without sacrificing data consistency or performance. . moreover, these modern databases also include several other awesome features that go beyond consistency, such as ease of use, serverless pricing models, built-in authentication, temporality, native graphql, and more. with a modern database, you can scale without opening pandora's box! and, if after reading this series of articles, you still choose not to use a strongly consistent distributed database, please at least make sure to tighten your wheels (in other words, read and understand different databases' consistency guarantees). article series why should you care? what can go wrong? what are the barriers to adoption? how do new algorithms help? our learning partner need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. leave a reply cancel reply your email address will not be published. required fields are marked * comment name * email * website save my name, email, and website in this browser for the next time i comment. get the css-tricks newsletter notify me of follow-up comments by email. copy and paste this code: micuno * leave this field empty all comments are held for moderation. we'll publish all comments that are on topic, not rude, and adhere to our code of conduct. you'll even get little stars if you do an extra good job. you may write comments in markdown. this is the best way to post any code, inline like `<div>this</div>` or multiline blocks within triple backtick fences (```) with double new lines before and after. want to tell us something privately, like pointing out a typo or stuff like that? contact us. we have a code of conduct. be cool. be helpful. the web is a big place. have fun. high five. related how do you stay up to date in this fast‚Å†-‚Å†moving industry? a good start is to sign up for our weekly hand-written newsletter. we bring you the best articles and ideas from around the web, and what we think about them. email address subscribe facebook @csstricks twitter @css youtube @realcsstricks instagram @real_css_tricks rss feed css-tricks* is created, written by, and maintained by chris coyier and a team of swell people. the tech stack for this site is fairly boring. that's a good thing! i've used wordpress since day one all the way up to v17, a decision i'm very happy with. i also leverage jetpack for extra functionality and local for local development. *may or may not contain any actual "css" or "tricks". other nav contact about guest writing jobs advertise license subscribe all authors codepen codepen is a place to experiment, debug, and show off your html, css, and javascript creations. flywheel logo flywheel css-tricks is hosted by flywheel, the best wordpress hosting in the business, with a local development tool to match. shoptalk is a podcast all about front-end web design and development. css-tricks presents üìÖ upcoming front-end conferences css-tricks presents the power of serverless for front-end developers