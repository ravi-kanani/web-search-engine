khan engineering khan engineering we're the engineers behind khan academy. we're building a free, world-class education for anyone, anywhere. subscribe subscribe with twitter subscribe with rss latest posts go + services = one goliath project kevin dangoor on december 20th how to upgrade hundreds of react components without breaking production jangmi jo on september 23rd how engineering principles can help you scale marta kosarchyn on august 21st making websites work with windows high contrast mode diedra rater on march 21st kotlin for python developers aasmund eldhuset on nov 29, 2018 using static analysis in python, javascript and more to make your system safer kevin dangoor on jul 26, 2018 kotlin on the server at khan academy colin fuller on jun 28, 2018 the original serverless architecture is still here kevin dangoor on may 31, 2018 what do software architects at khan academy do? kevin dangoor on may 14, 2018 new data pipeline management platform at khan academy ragini gupta on apr 30, 2018 untangling our python code carter j. bastian on apr 16, 2018 slicker: a tool for moving things in python ben kraft on apr 2, 2018 the great python refactor of 2017 and also 2018 craig silverstein on mar 19, 2018 working remotely scott grant on oct 2, 2017 tips for giving your first code reviews hannah blumberg on sep 18, 2017 let's reduce! a gentle introduction to javascript's reduce method josh comeau on jul 10, 2017 creating query components with apollo brian genisio on jun 12, 2017 migrating to a mobile monorepo for react native jared forsyth on may 29, 2017 memcached-backed content infrastructure ben kraft on may 15, 2017 profiling app engine memcached ben kraft on may 1, 2017 app engine flex language shootout amos latteier on apr 17, 2017 what's new in oss at khan academy brian genisio on apr 3, 2017 automating app store screenshots bryan clark on mar 27, 2017 it's okay to break things: reflections on khan academy's healthy hackathon kimerie green on mar 6, 2017 interning at khan academy: from student to intern shadaj laddad on dec 12, 2016 prototyping with framer nick breen on oct 3, 2016 evolving our content infrastructure william chargin on sep 19, 2016 building a really, really small android app charlie marsh on aug 22, 2016 a case for time tracking: data driven time-management oliver northwood on aug 8, 2016 time management at khan academy several authors on jul 25, 2016 hackathons can be healthy tom yedwab on jul 11, 2016 ensuring transaction-safety in google app engine craig silverstein on jun 27, 2016 the user write lock: an alternative to transactions for google app engine craig silverstein on jun 20, 2016 khan academy's engineering principles ben kamens on jun 6, 2016 minimizing the length of regular expressions, in practice craig silverstein on may 23, 2016 introducing swifttweaks bryan clark on may 9, 2016 the autonomous dumbledore evy kassirer on apr 25, 2016 engineering career development at khan academy ben eater on apr 11, 2016 inline css at khan academy: aphrodite jamie wong on mar 29, 2016 starting android at khan academy ben komalo on feb 29, 2016 automating highly similar translations kevin barabash on feb 15, 2016 the weekly snippet-server: open-sourced craig silverstein on feb 1, 2016 stories from our latest intern class 2015 interns on dec 21, 2015 kanbanning the learnstorm dev process kevin dangoor on dec 7, 2015 forgo js packaging? not so fast craig silverstein on nov 23, 2015 switching to slack benjamin pollack on nov 9, 2015 receiving feedback as an intern at khan academy david wang on oct 26, 2015 schrödinger's deploys no more: how we update translations chelsea voss on oct 12, 2015 i18nize-templates: internationalization after the fact craig silverstein on sep 28, 2015 making thumbnails fast william chargin on sep 14, 2015 copy-pasting more than just text sam lau on aug 31, 2015 no cheating allowed!! phillip lemons on aug 17, 2015 fun with slope fields, css and react marcos ojeda on aug 5, 2015 khan academy: a new employee's primer riley shaw on jul 20, 2015 how wooden puzzles can destroy dev teams john sullivan on jul 6, 2015 babel in khan academy's i18n toolchain kevin barabash on jun 22, 2015 tota11y - an accessibility visualization toolkit jordan scales on jun 8, 2015 meta about this blog ka's mission report a bug activate tota11y go + services = one goliath project by kevin dangoor on december 20th go + services = one goliath project khan academy is embarking on a huge effort to rebuild our server software on a more modern stack in go. at khan academy, we don’t shy away from a challenge. after all, we’re a non-profit with a mission to provide a “free world-class education to anyone, anywhere”. challenges don’t get much bigger than that. our mission requires us to create and maintain software to provide tools which help teachers and coaches who work with students, and a personalized learning experience both in and out of school. millions of people rely on our servers each month to provide a wide variety of features we’ve built up over the past ten years. ten years is a long time in technology! we chose python as our backend server language and it has been a productive choice for us. of course, ten years ago we chose python 2 because python 3 was still very new and not well supported. the python 2 end-of-life now, in 2019, python 3 versions are dominant and the python software foundation has said that python 2 reaches its official end-of-life on january 1, 2020, so that they can focus their limited time fully on the future. undoubtedly, there are still millions of lines of python 2 out there, but the truth is undeniable: python 2 is on its way out. moving from python 2 to 3 is not an easy task. beyond that hurdle, which has been widely written about elsewhere, we also have a bunch of other apis in libraries we use which have undergone huge changes. all of these differences mean that we’d have to split our code to run in at least two services (the old python 2 codebase and the python 3 replacement) which can coexist during the transition. for all of that work, we’d receive these benefits: likely a 10-15% boost in backend server code performance python 3’s language features other languages given all of the work required and the relatively small benefits, we wanted to consider other options. we started using kotlin for specific jobs within khan academy a year ago. its performance benefits have saved us money, which we can apply in other ways to help people around the world learn. if we moved from python to a language that is an order of magnitude faster, we can both improve how responsive our site is*and*decrease our server costs dramatically. moving to kotlin was an appealing alternative. while we were at it, we decided to dig deeper into other options. looking at the languages that have first-class support in google app engine, another serious contender appeared: go. kotlin is a very expressive language with an impressive set of features. go, on the other hand, offers simplicity and consistency. the go team is focused on making a language which helps teams reliably ship software over the long-term. as individuals writing code, we can iterate faster due to go’s lightning quick compile times. also, members of our team have years of experience and muscle memory built around many different editors. go is better supported than kotlin by a broad range of editors. finally, we ran a bunch of tests around performance and found that go and kotlin (on the jvm) perform similarly, with kotlin being perhaps a few percent ahead. go, however, used a lot less memory, which means that it can scale down to smaller instances. we still like python, but the dramatic performance difference which go brings to us is too big to ignore, and we think we’ll be able to better support a system running on go over the years. moving to go will undeniably be more effort than moving to python 3, but the performance win alone makes it worth it. from monolith to services with a few exceptions, our servers have historically all run the same code and can respond to a request for any part of khan academy. we use separate services for storing data and managing caches, but the logic for any request can be easily traced through our code and is the same regardless of which server responds. when a function calls another in a program, those calls are extremely reliable and very fast. this is a fundamental advantage of monoliths. once you break up your logic into services, you’re putting slower, more fragile boundaries between parts of your code. you also have to consider how, exactly, that communication is going to happen. do you put a publish/subscribe bus in between? make direct http or grpc calls? dispatch via some gateway? even recognizing this added complexity, we’re breaking up our monolith into services. there’s an element of necessity to it, because new go code would have to run in a separate process at least from our existing python. the added complexity of services is balanced by a number of big benefits: by having more services which can be deployed independently, deployment and test runs can move more quickly for a single service, which means engineers will be able to spend less of their time on deployment activities. it also means they’ll be able to get changes out more quickly when needed. we can have more confidence that a problem with a deployment will have a limited impact on other parts of the site. by having separate services, we can also choose the right kinds of instances and hosting configuration needed for each service, which helps to optimize both performance and cost. we posted a series of blog posts (part 1, part 2, part 3) about how we had performed a significant refactoring of our python code, drawing boundaries and creating constraints around which code could import which other code. those boundaries provided a starting point for thinking about how we’d break our code into services. craig silverstein and ben kraft led an effort to figure out an initial set of services and how we would need to accommodate the boundaries between them. in our current monolith, code is free to read and update any data models it needs to. to keep things sane, we made some rules around data access from services, but that’s a topic for another day. cleaning house ten years is a long time in technology. graphql didn’t exist in 2009, and two years ago we decided to migrate all of our http get apis to graphql, later deciding to also adopt graphql mutations. we adopted react just after it was introduced, and it has spread to much of our web frontend. google cloud has grown in breadth of features. server architectures have moved in the direction of independently deployable services. ten years is also a long time for a product. we have introduced an incredible number of features, some of which have very little usage today. some of our older features were built with patterns that we no longer think fit our best practices. we’re going to do a lot of housecleaning in python. we’re very aware of the second-system effect and our goal with this work is not to “create the perfect system” but rather to make it easier to port to go. we started some of these technical migrations earlier, and some of them will continue on past the point at which our system is running in go, but the end result will be more modern and coherent. we’ll only generate web pages via react server side rendering, eliminating the jinja server-side templating we’ve been using we’ll use graphql federation to dispatch requests to our services (and to our legacy python code during the transition) where we need to offer rest endpoints, we’ll do so through a gateway that converts the request to graphql we will rely more heavily on fastly, our cdn provider, to enable more requests to be served quickly, closer to our users, and without requiring our server infrastructure to handle the request at all we’re going to deprecate some largely unused, outdated features that are an ongoing maintenance burden and would slow down our path forward there are other things we might want to fix, but we’re making choices that ultimately will help us complete the project more quickly and safely. what’s not changing everything i’ve described to this point is a huge amount of change, but there is a lot that we’re not changing. as much as possible, we’re going to port our logic straight from python to go, just making sure the code looks like idiomatic go when it’s done. we’ve been using google app engine since day 1, and it has worked well for us and scaled automatically as we’ve grown. so, we’re going to keep using app engine for our new go services. we’re using google cloud datastore as our database for the site, which is also staying the same. this also applies to the variety of other google cloud service we use, which have been performing well and scaling with our needs. the plan as of december 2019, we have our first few go services running in production behind an apollo graphql gateway. these services are pretty small today, because the way we’re doing the migration is very incremental. this incremental switchover is another good topic to talk about on another day (subscribe to our rss feed or our twitter account to read new posts as they go live). for us, 2020 is going to be filled with technical challenge and opportunity: converting a large python monolith to graphql-based services in go. we’re excited about this project, which we’ve named goliath (you can probably imagine all of the “go-” names we considered!). it’s a once in a decade opportunity to take a revolutionary step forward, and a big example of how we live our "we champion quality" engineering principle. if you’re also excited about this opportunity, check out our careers page. as you can imagine, we’re hiring engineers! previous post how to upgrade hundreds of react components without breaking production