skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author paul hanaoka is a design manager at liferay, based in the suburbs of los angeles, and serving the north american teams. his passion is at the intersection of … more about paul … march 25, 2020 leave a comment how should designers learn to code? git, html/css, engineering principles (part 2) 20 min read tools, workflow, design share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → in part 1, paul explained the basics of the terminal, shared a few productivity hacks to get you started, and how to choose a code editor. in this part, he’ll continue with the topics of version control (git), html and css, semantic code, and a brief introduction to some key engineering principles. literally, tomes have been written on version control. nevertheless, i will start by sharing a brief explanation and other introductory content to whet your appetite for further study. version control (not to be confused with version history) is basically a way for people to collaborate in their own environments on a single project, with a single main source of truth (often called the “master” branch). i’ll go over today is the bare minimum you’ll need to know in order to download a project, make a change, and then send it to master. there are many types of version control software and many tools for managing and hosting your source code (you may have heard of gitlab or bitbucket). git and github are one of the more common pairs, my examples will reference github but the principles will apply to most other source code managers. aside: for a more comprehensive and technical introduction, see tobias gunther’s article. if you prefer a more hands-on approach, github has an excellent step-by-step guide. collecting data, the powerful way did you know that css can be used for collecting statistics? indeed, there's even a css-only approach for tracking ui interactions using google analytics. read a related article → your first contribution before doing these steps, you’ll need a few things set up: a github account, node and npm installed on your computer, a high tolerance for pain or a low threshold for asking others for help. step 1: fork (get a copy of the code on your github account) on github, you will fork (fork = create a copy of the code in your account; in the following illustration, the blue, orange, red, and green lines show forks) the repository (repo) in question. by creating branches off of the master, it’s possible for multiple people to contribute to different areas of a project and then merge their work together. (large preview) you do this by navigating to the repo in github and clicking the “fork” button, currently at the top right-hand corner of a repo. this will be the “origin” — your fork on your github account. as an example, navigating to https://github.com/yourgithubusername/liferay.design should show your fork of the liferay.design repo. this is victorvalle’s github fork. (large preview) step 2: clone (download the code to your computer) in your terminal, navigate to where you’d like to store the code. personally, i have a /github folder in my /user folder — it makes it easier for me to organize it this way. if you’d like to do that, here are the steps — after typing these commands into your terminal window, press the ↵ key to execute: cd ~/             ## you'll usually start in your root directory, but just in case you don't this will take you there
mkdir github      ## this creates a "github" folder — on osx it will now be located at users/your-username/github
cd github         ## this command navigates you inside the github folder now that you’re in the /github folder, you will clone (download a copy of the code onto your computer) the repo. clone https://github.com/yourgithubusername/liferay.design once you enter this command, you’ll see a bunch of activity in the terminal — something like this: cloning into 'liferay.design'...
remote: enumerating objects: 380, done.
remote: total 380 (delta 0), reused 0 (delta 0), pack-reused 380
receiving objects: 100% (380/380), 789.24 kib | 2.78 mib/s, done.
resolving deltas: 100% (189/189), done.
 step 3: install (get it running on your machine) navigate into the /project folder. in this case, we’ll enter cd liferay.design. most projects will include a readme.md file in the /root folder, this is typically the starting place for installing and running the project. for our purposes, to install, enter npm install. once it’s installed, enter npm run dev. congratulations! you now have the site available on your local computer — typically projects will tell you where it’s running. in this case, open up a browser and go to localhost:7777. step 4: commit (make some changes and save them) a commit is a collection of changes that you make; i’ve heard it described as saving your progress in a game. there are many opinions on how commits should be structured: mine is that you should create a commit when you’ve achieved one thing, and if you were to remove the commit, it wouldn’t completely break the project (within reason). if you aren’t coming to a repo with a change in mind, a good place to go is the ‘issues’ tab. this is where you can see what needs to be done in the project. if you do have an idea for some change, go ahead and make it. once you’ve saved the file(s), here are the steps required to create a commit: git status                                         ## this will print out a list of files that you've made changes in
git add path/to/folder/or/file.ext                 ## this will add the file or folder to the commit
git commit -m 'summarize the changes you've made'  ## this command creates a commit and a commit message tip: the best recommendation i’ve ever seen for commit messages is from chris breams’s “how to write a git commit message”. a properly formed git commit subject line should always be able to complete the following sentence: “if applied, this commit will [your subject line here].” for more info on commits, check “why i create atomic commits in git” by clarice bouwer. step 5: push (send your changes to your origin) once you’ve made some changes on your computer, before they can be merged into the master branch (added to the project), they need to be moved from your local to your remote repo. to do this, enter git push origin in the command line. step 6: pull request (ask for your changes to be merged into upstream) now that your changes have gone from your fingers to your computer, to your remote repository — it’s now time to ask for them to be merged into the project via a pull request (pr). the easiest way to do this is by going to your repo’s page in github. there will be a small message right above the file window that says “this branch is x commits ahead repo-name:branch” and then options to “pull request” or “compare”. clicking the “pull request” option here will take you to a page where you can compare the changes and a button that says “create pull request” will then take you to the “open a pull request” page where you’ll add a title and include a comment. being brief, but detailed enough in the comment, will help project maintainers understand your proposed changes. there are cli tools like node gh (github also recently released a beta of their cli tool) that allow you to initiate and manage pull requests in the terminal. at this point you may prefer to use the web interface, and that’s great! so do i. the ‘pull request’ and ‘compare’ options will appear once your fork has diverged from the upstream repo. (large preview) bonus step: remote (link all the repos) at this point, we have three repository references: upstream: the main repo that you’re tracking, often it’s the repo that you forked; origin: the default name of the remote that you clone; local: the code that is currently on your computer. so far, you have #2 and #3 — but #1 is important because it’s the primary source. keeping these three things in-line with each other is going to help the commit history stay clean. this helps project maintainers as it eliminates (or at least minimizes) merge conflicts when you send pull requests (pr’s) and it helps you get the latest code and keep your local and origin repositories up-to-date. set an upstream remote to track the upstream remote, in your terminal enter the following: git remote add upstream https://github.com/liferay-design/liferay.design now, check to see what remotes you have available — enter git remote -v into your terminal, you should see something like: origin and upstream are the most common labels for remotes — ‘origin’ is your fork, ‘upstream’ is the source. (large preview) origin   https://github.com/yourgithubusername/liferay.design (fetch)
origin    https://github.com/yourgithubusername/liferay.design (push)
upstream  https://github.com/liferay-design/liferay.design (fetch)
upstream  https://github.com/liferay-design/liferay.design (push) this will allow you to quickly get the latest version of what is upstream — if you haven’t worked in a repo in a long time and don’t have any local changes that you want to keep, this is a handy command that i use: git pull upstream master && git reset --hard upstream/master github help is a great resource for this and many other questions you might have. html and css: starting with semantics on the web, there is an endless supply of resources for learning html and css. for the purposes of this article, i’m sharing what i would recommend based on the mistakes i made how i first learned to write html and css. what are html and css? before we get any further, let’s define html and css. html stands for hypertext markup language. hypertext: “hypertext is text displayed on a computer display or other electronic devices with references (hyperlinks) to other text that the reader can immediately access.” — “hypertext” on wikipedia markup language: “…a system for annotating a document in a way that is syntactically distinguishable from the text.” — “markup language” on wikipedia in case you also don’t know what a lot of those words mean — briefly put, html is the combination of references (links) between documents on the web, and tags that you use to give structure to those documents. there’s an html5 tag for pretty much any basic element — otherwise you can always use a div! (large preview) for a thorough introduction to html and css, i highly recommend the introduction to html and css first steps, both on the mozilla developer network (mdn) web docs. that, along with the excellent articles that websites such as css tricks, 24 ways and countless of others provide, contain basically everything you’ll ever need to reference with regards to html/css. there are two main parts of an html document: the <head> and the <body>. - the <head> contains things that aren’t displayed by the browser — metadata and links to imported stylesheets and scripts. - the <body> contains the actual content that will be rendered by the browser. to render the content, the browser reads the html, provides a base layer of styles depending on the types of tags used, adds additional layers of styles provided by the website itself (the styles are included in/referenced from the <head>, or are inline), and that is what we see in the end. (note: there is often also the additional layer of javascript but it’s outside of the scope of this article.) css stands for cascading style sheets — it is used to extend the html by making it easier to give documents a custom look and feel. a style sheet is a document that tells the html what elements should look like (and how they should be positioned) by setting rules based on tags, classes, ids, and other selectors. cascading refers to the method for determining which rules in a sheet take priority in the inevitable event of a rule conflict. “‘cascading’ means that styles can fall (or cascade) from one style sheet to another, enabling multiple style sheets to be used on one html document.” — cascade — max design css often gets a bad reputation — in sites with lots of style sheets it can quickly become unwieldy, especially if there aren’t documented, consistent methods used (more on that later) — but if you use it in an organized fashion and following all the best practices, css can be your best friend. especially with the layout capabilities that are now available in most modern browsers, css is not nearly as necessary to hack and fight as it once was. rachel andrew wrote a great guide, how to learn css — and one of the best things to know before you start is that: “you don’t need to commit to memorizing every css property and value.” — rachel andrew instead, it’s far more vital to learn the fundamentals — selectors, inheritance, the box model, and most importantly, how to debug your css code (hint: you will need the browser developer tools). don’t worry about memorizing the syntax for the background property, and don’t worry if you forget about how exactly to align stuff in flexbox (the css tricks guide to flexbox is possibly one of my top-10 most visited pages, ever!); google and stack overflow are your friends when it comes to css properties and values. some code editors even have built-in autocomplete so you don’t even need to search on the web in order to be able to figure out all the possible properties of a border, for example. one of my favorite new features in firefox 70 is the inactive css rules indicator. it will save you hours of time trying to figure out why a style isn’t being applied. kids these days have it so easy! (large preview) semantics let’s start with semantic code. semantics refers to the meanings of words, semantic code refers to the idea that there is meaning to the markup in any given language. there are many reasons why semantics are important. if i could summarize this, i would say that if you learn and use semantic code, it will make your life a lot easier because you will get a lot of things for free — and who doesn’t like free stuff? for a more complete introduction to semantic code, see paul boag’s brief blog post on the topic. semantics gives you many benefits: default styles for example, using a headline tag <h1> for the title of your document will make it stand out from the rest of the document’s contents, much like a headline would. accessible content your code will be accessible by default, meaning it will work with screen readers and will be easier to navigate with a keyboard. seo benefits semantic markup is easier for a machine to read, which makes it more accessible to search engines. performance benefits clean html is the foundation for a high-performing site. and clean html will also likely lead to cleaner css which means less code overall, making your site or app faster. note: for a more in-depth look into semantics and html, heydon pickering wrote “structural semantics: the importance of html5 sectioning elements” which i highly recommend reading. engineering principles and paradigms: the basics abstraction there are tons of applications, tangents, and levels we could explore over the concept of abstraction — too many for this article which is intended to give you a brief introduction into concepts so that you are aware of them as you continue to learn. abstraction is a foundational engineering paradigm with a wide variety of applications — for the purposes of this article, abstraction is separating form from function. we’ll apply this in three areas: tokens, components, and the don’t repeat yourself principle. tokens if you’ve used a modern design tool for any length of time, you’ve probably encountered the idea of a token. even photoshop and illustrator now have this idea of shared styles in a centralized library — instead of hard-coding values into a design, you use a token. if you’re familiar with the concept of css or sass variables, you’re already familiar with tokens. one layer of abstraction with tokens is to assign a name to a color — for example, $blue-00 can be mapped to a hex value (or an hsl value, or whatever you want) — let’s say #0b5fff. now, instead of using the hex value in your stylesheets, you use the token value — that way if you decide that blue-00 is actually #0b36ce, then you only have to change it in a single place. this is a nice concept. tokens for colors in the lexicon alerts component helps keep things dry. (large preview) if you take this same paradigm of abstraction and go a layer further, you can token-ception — and assign a variable to a functional value. this is particularly useful if you have a robust system and want to have different themes within the system. a functional example of this would be assigning a variable like $primary-color and map that to $blue-00 — so now you can create markup and instead of referencing blue, you’re referencing a functional variable. if you ever want to use the same markup, but with a different style (theme), then you only need to map $primary-color to a new color, and your markup doesn’t need to change at all! magic! components in the past 3-4 years, the idea of components and componentization has become more relevant and accessible to designers. the concept of symbols (pioneered by macromedia/adobe fireworks, later expanded by sketch, and then taken to the next level by figma and framer), is now more widely available in most design tools (adobe xd, invision studio, webflow, and many others). componentization, even more than tokens, can separate the form of something from the function of it — which helps to improve both the form and the function. one of the more notable early examples is nicole sullivan’s media object component. at first glance you might not realize that a whole page is essentially composed of a single component, rendered in different ways. in this way, we can re-use the same markup (form), modifying it slightly by passing in options or parameters, and styles — and have it provide a variety of value (function). don’t repeat yourself dry (don’t repeat yourself) is one of my favorite principles — creating things that can be reused over and over is one of the small victories you can have when coding. while you often can’t (and arguably shouldn’t) strive to apply the dry principle 100% of the time, every time — it’s at least beneficial to be aware of this so that as you’re working, you can consider how you can make whatever you’re working on more reusable. a note on the rule of three: a corollary to the dry principle is the rule of three — essentially, once you re-use (copy/paste) something three times, you should rewrite it into a reusable component. like the pirate’s code, it’s more of a guideline than a hard and fast rule, and can vary from component to component and from project to project. css and styling methodologies: atomic vs. bem there are a lot of different ways to organize and write css code — atomic and bem are only two of the many that you’re likely to come across. you don’t have to “pick” a single one, nor do you have to follow them exactly. most of the teams i’ve worked with usually have their own unique blend, based on the project or technology. it is helpful to be familiar with them so that over time, you can learn which approach to take depending on the situation. all of these approaches go beyond “just” css and styling, and can often influence the tooling you use, the way you organize your files, and potentially the markup. atomic css not to be confused with atomic web design — atomic (perhaps more aptly referred to as “functional”) css, is a methodology that essentially favors using small, single-purpose classes to define visual functions. a few notable libraries: atomic css by steve carlson; tachyons by adam morse; tailwind css by adam wathan. what i like about this method is that it allows you to quickly style and theme things — one of the biggest drawbacks is that your markup can get pretty cluttered, pretty fast. check john polacek’s article on css-tricks for a full introduction to atomic css. bem the bem philosophy is a great precursor to a lot of the modern javascript frameworks like angular, react, and vue. “bem (block, element, modifier) is a component-based approach to web development.” — bem: quick start basically, everything that can be reused is a block. blocks are comprised of elements, something that can’t be used outside of a block, and potentially other blocks. modifiers are things that describe the status of something or the way it looks or behaves. personally, i like the theory and philosophy of bem. what i do not like is the way that things are named. way too many underscores, hyphens, and it can feel unnecessarily repetitive (.menu, .menu__item, etc). recommended reading: bem for beginners written by inna belaya thank u, next(.js) after you have sufficiently mastered these topics, don’t worry, there is still plenty to learn. some suggestions: functional and object-oriented programming we touched on it lightly, but there’s plenty more to learn beyond css. higher-level languages and frameworks typescript, ruby, react, vue are the next things you’ll tackle once you have a strong grasp of html and css. querying languages and using data learning about graphql, mysql, rest apis will take your coding ability to the next level. conclusion: designers who code != software engineers hopefully, this article has shown you that learning to code isn’t as difficult as you may have previously thought. it can take a lot of time, but the amount of resources available on the internet is astounding, and they’re not decreasing — quite the opposite! one significant point that i want to emphasize is that “coding” is not the same as “software engineering” — being able to fork a repo and copy/paste in code from stack overflow can get you a long way, and while most, if not all, software engineers that i know have done that — you must use your new-found skills with wisdom and humility. for everything you can now access with some engineering prowess, there is that much more that you don’t know. while you may think that a feature or style is easy to accomplish because — “hey, i got it working in devtools!” or “i made it work in codepen.” — there are many engineering processes, dependencies, and methods that you probably don’t know that you don’t know. all of that is to say — don’t forget that we are still designers. our primary function is to add business value through the lens of understanding customer or user problems and synthesizing them with our knowledge of design patterns, methods, and processes. yes, being a “designer who writes code” can be very useful and will expand your ability to add this value — but we still need to let engineers make the engineering decisions. anything amiss? there’s a good chance that something in this post was obscure, obtuse, and/or obsolete and i’d love the opportunity to make it better! please leave a comment below, dm me, or @mention me on twitter so i can improve. further reading coding bootcamps vs. computer science degrees: what employers want and other perspectives (kyle thayer) how to start using sketch and framer x (by martina pérez, smashing magazine) introduction to linux commands (by paul tero, smashing magazine) become a command-line power user with oh my zsh and z (by wes bos, smashing magazine) a list of the common cmd.exe and unix commands that you can use in powershell (microsoft docs) regular-expressions.info (by jan goyvaerts) regexone.com (learn regular expressions with simple interactive exercises) batch resizing using command line and imagemagick (by vlad gerasimov, smashing magazine) shortcuts and tips for improving your productivity with sublime text (by jai pandya, smashing magazine) visual studio code can do that? (by burke holland, smashing magazine) why version history is not version control (by josh brewer) modern version control with git (by tobias günther, smashing magazine) “hello world” (a github step-by-step guide) how to install node.js and npm on a mac (by dave mcfarland) how to install node.js and npm on windows (by dejan tucakov) why i create atomic commits in git (by clarice bouwer) how to write a git commit message (by chris breams) semantic code: what? why? how? (by paul boag) structural semantics: the importance of html5 sectioning elements (by heydon pickering, smashing magazine) designing for performance: chapter 4. optimizing markup and styles (by lara c. hogan, o’reilly media) the media object saves hundreds of lines of code (by nicole sullivan) let’s define exactly what atomic css is (by john polacek, css tricks) bem for beginners: why you need bem (by inna belaya, smashing magazine) javascript for cats: an introduction for new programmers roadmap.sh: frontend developer functional programming vs oops : explain like i’m five why, how, and when to use semantic html and aria (by adam silver, css tricks) html semantics (an ebook by smashing magazine) the fundamentals - html + css (on syntax.fm) cascade and inheritance (westciv.com) css tricks (by chris coyier) getting started with css layout (by rachel andrew, smashing magazine) introduction to html (mdn web docs) css first steps (mdn web docs) javascript first steps (mdn web docs) 24 ways (by drew mclellan) (mb, yk, il) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top