skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the authors paul irish is a front-end developer who loves the web. he’s thinking a lot about how to make you more productive with tools that improve your workflow help you …more about paul irish &amp; paul lewis … october 2, 2015 leave a comment introducing rail: a user-centric model for performance 11 min read coding, performance, strategy share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → there’s no shortage of performance advice, is there? the elephant in the room is the fact that it’s challenging to interpret: everything comes with caveats and disclaimers, and sometimes one piece of advice can seem to actively contradict another. phrases like “the dom is slow” or “always use css animations” make for great headlines, but the truth is often far more nuanced. there’s no shortage of performance advice, is there? the elephant in the room is the fact that it’s challenging to interpret: everything comes with caveats and disclaimers, and sometimes one piece of advice can seem to actively contradict another. phrases like “the dom is slow” or “always use css animations” make for great headlines, but the truth is often far more nuanced. take something like loading time, the most common performance topic by far. the problem with loading time is that some people measure speed index, others go after first paint, and still others use body.onload, domcontentloaded or perhaps some other event. it’s rarely consistent. when it comes to other ways to measure performance, you’ve probably seen enough javascript benchmarks to last a lifetime. you may have also heard that 60 fps matters. but when? all the time? seems unrealistic. further reading on smashingmag: front-end performance checklist 2017 getting ready for http/2 everything you need to know about amp progressive enhancement improving smashing magazine’s performance very few of us have unlimited time to throw at optimization work, far from it, and we need criteria that help us decide what’s important to optimize (and what’s not!). when all is said is done, we want and need clear guidance on what “performant” means to our users, because that’s who we’re building for. on the chrome team, we’ve been thinking about this, and we’ve come up with a model to put the user right back in the middle of the performance story. we call it the rail model. if you want the tl;dr on rail to share with your team, here you go! rail is a model for breaking down a user’s experience into key actions (for example, tap, drag, scroll, load). rail provides performance goals for these actions (for example, tap to paint in under 100 milliseconds). rail provides a structure for thinking about performance, so that designers and developers can reliably target the highest-impact work. before diving into what rail involves and how it could be helpful in your project, let’s step back and look at where it comes from. let’s start with every performance-minded person’s least favorite word in the whole wide world: “slow.” “slow” is changing the dom slow? what about loading a <script> in the <head>? javascript animations are slower than css ones, right? also, does a 20-millisecond operation take too long? what about 0.5 seconds? 10 seconds? what does slow really mean? while it’s true that different operations take different amounts of time to complete, it’s hard to say objectively whether something is slow or fast without the context of when it’s happening. for example, code running during idle time, in a touch handler or in the hot path of a game loop each has different performance requirements. put another way, the people using your website or app have different performance expectations for each of those contexts. like every aspect of ux, we build for our users, and what they perceive is what matters most. in fact, number one on google’s ten things we know to be true is “focus on the user and all else will follow.” asking “what does slow mean?,” then, is really the wrong question. instead, we need to ask “what does the user feel when they’re interacting with the things we build?” putting the user in the center of performance luckily for us, there’s long-standing academic hci research on this topic, and you may have seen it before in jakob nielsen’s work on response time limits. based on those thresholds, and adding an extra one for animations (because it’s 2015 and we all love a bit of showbiz), we get the following: 100 milliseconds. respond to a user action within this time window and they will feel like the result is immediate. any longer and that connection between action and reaction breaks. 1 second. within this window, things feel part of a natural and continuous progression of tasks. beyond it, the user will lose focus on the task they were performing. for most users on the web, loading a page or changing views represents a task. 16 milliseconds. given a screen that is updating 60 times per second, this window represents the time to get a single frame to the screen (professor math says 1000 ÷ 60 = ~16). people are exceptionally good at tracking motion, and they dislike it when their expectation of motion isn’t met, either through variable frame rates or periodic halting. these perception thresholds are great because they give us the building blocks we need. what we need to do next is map them to reality. let’s consider a typical interaction that our users have: in that brief session were a number of distinct interactions: waiting for the page to load, watching an animation, scrolling the page, tapping an icon, watching the navigation animate open, waiting for the page to load, watching an animation, scrolling the page. labeling those actions from the video would give us something like this: (view large version) each of those color blocks represents a type of action, and you can see that there are four of them. and there are four letters in rail. curious. here’s another user journey that we can break down and label, this time from voice memos: we can break down user interactions and categorize them into four distinct areas. at google, we call these areas rail, and each comes with its own performance goals, which are based on the human perception thresholds we just saw. the rail performance model rail stands for response, animation, idle and load. these four distinct areas are a way to reason about the actions in your websites and apps. if you optimize based on each area’s performance goals (which we got from those perception thresholds), then your users will be very happy. let’s look at each one in detail. 1. response if a user clicks on a button, you have to respond to their click before they notice any lag. this applies to any input, really, whether it’s toggling a form control or starting an animation. if it doesn’t happen in a reasonable window of time, then the connection between action and reaction breaks and the user will notice. response is all about input latency: the lag between the finger touching the glass and the resulting pixels hitting the screen. have you ever tapped on something and it took so long to respond that you started wondering whether it registered your tap? that’s exactly the kind of thing we want to avoid! response’s primary interaction is: tapping — when the user taps or clicks on a button or icon (for example, tapping a menu icon to open off-screen navigation). to respond responsively, we would: provide feedback in less than 100 milliseconds after initial input. ideally, the feedback would show the desired state. but if it’s going to take a long time, then a loading indicator or coloring for the active state will do. the main thing is to acknowledge the user so that they don’t start wondering whether their tap was registered. 2. animation animation is a pillar of modern apps, from scrolling to view transitions, and we must be judicious with what we do in this period of time, because the user will often be interacting directly and will really notice if the frame rate varies. however, the user expects very smooth feedback for more than what falls under the classic definition of animation. animation includes the following: visual animation. this includes entrance and exit animations, tweened state changes, and loading indicators. scrolling. this refers to when the user starts scrolling and lets go and the page is flung. drag. while we need to respond to the user’s interaction in under 100 milliseconds, animation might follow as a result, as when panning a map or pinching to zoom. to animate properly, each frame of animation should be completed in less than 16 milliseconds, thereby achieving 60 fps (1 second ÷ 60 = 16.6 milliseconds). 3. idle creating apps that respond and animate well often requires deferment of work. the optimistic ui patterns leverage this technique to great effect. all sorts of work that must be completed likely does not need to happen within a critical time window in the same way as “response” or “load”: bootstrapping the comments functionality, initializing components, searching and sorting data, and beaconing back analytics data are all non-essential items that we can do when the browser is idle. to use idle time wisely, the work is grouped into blocks of about 50 milliseconds. why? should a user begin interacting, we’ll want to respond to them within the 100-millisecond response window, and not be stuck in the middle of a 2-second template rendering. 4. load page-loading time is a well-trodden area of performance. we’re most interested in getting the user to the first meaningful paint quickly. once that’s delivered, the app must remain responsive; the user mustn’t encounter trouble when scrolling, tapping or watching animations. this can be super-challenging, especially when much of the work for a page shares a single thread. to load pages quickly, we aim to deliver the first meaningful paint in under 1 second. beyond this, the user’s attention starts to wander and the perception of dealing with the task at hand is broken. reaching this goal requires prioritizing the critical rendering path and often deferring subsequent non-essential loads to periods of idle time (or lazy-loading them on demand). performance goals performance is essentially the art of avoiding work. and when it’s unavoidable, make any work you do as efficient and well timed as possible. with the stages of rail interaction laid out, let’s summarize the goals: response animation idle page load tap to paint in less than 100 milliseconds. each frame completes in less than 16 milliseconds. use idle time to proactively schedule work. satisfy the “response” goals during full load. drag to paint in less than 16 milliseconds. complete that work in 50-millisecond chunks. get first meaningful paint in 1,000 milliseconds. a note on measurement here are a few handy tips on measuring your project’s performance profile: measuring these on a macbook pro or comparable machine (which many of us designers and developers have) won’t give a representative idea of your mobile users. common phones can be over ten times slower than a desktop! a nexus 4 is a good middle-of-the-road device to use. “regular 3g” is recommended for network throttling. also, look at your analytics to see what your users are on. you can then mimic the 90th percentile’s experience for testing. what about battery and memory? delivering on all of the goals above but leaving the user with 10% battery and 0% available memory isn’t putting the user first. we’re not yet sure how to quantify being a responsible citizen of the shared resources, but rail may some day get a b (for battery) and an m (for memory), turning into blaimr, primal or something else equally fun and memorable. business impact of rail many of us do what we do because we love building awesome things. we don’t work in a vacuum, though, and sometimes we have to make the business case to managers, stakeholders and clients to be able to prioritize performance as part of the user experience. luckily, many large companies have shared numbers that help us make our case: google: 2% slower = 2% less searching per user yahoo: 400 milliseconds faster = 9% more traffic aol: faster pages = more page views amazon: 100 milliseconds faster = 1% more revenue aberdeen group: 1 second slower = 11% fewer page views, 7% less conversion google uses website speed in search ranking. summary the rail model is a lens to look at a user’s experience with a website or app as a journey comprising individual interactions. once you know each interaction’s area, you will know what the user will perceive and, therefore, what your goals are. sometimes it takes extra effort, but if you’re kind to the user, they’ll be good to you. resources if you want more information on rail and how to optimize your websites and apps, take a look at these. presentations on rail “performance rail’s: the art and science of optimizing for silicon and wetware” (slides), ilya grigorik, google, may 2015 “how users perceive the speed of the web” (slides), paul irish, fluentconf, april 2015 “performance on rails” (video), paul lewis, nordic.js, september 2015 guidance and documentation “optimizing performance,” web fundamentals, google developers “browser rendering optimization” (course), udacity “profile” (performance), google web tools, google developers “the rail performance model,” web fundamentals, google developers performance audits performance audit of theverge.com” (july 2015) performance audit of imore.com” (july 2015) performance audit of m.espn.com” (april 2015) performance audit of squarespace.com” (april 2015) performance audit of cafepress.com” (april 2015) performance audit of cnet, wikipedia and time.com” (february 2015) performance audit of wikipedia rich editor” (february 2015) academic research on perceivable performance 1968: “response time in man-computer conversational transactions” (pdf), robert b. miller, fall joint computer conference 1968 1991: “response times: the 3 important limits,” jakob nielsen, nielsen norman group 2004: “a study on tolerable waiting time: how long are web users willing to wait?” (pdf), fiona fui-hoon nah, behaviour and information technology, 2004 2005: “interaction in 4-second bursts: the fragmented nature of attentional resources in mobile hci” (pdf), antti oulasvirta, sakari tamminen, virpi roto, and jaana kuorelahti, interruptions in human computer interaction 2006: “quantifying interactive user experience on thin clients” (pdf), niraj tolia, david g. andersen, and m. satyanarayanan, the internet suspend/resume project, carnegie mellon 2012: “characterizing web use on smartphones” (pdf), chad c. tossell, philip kortum, ahmad rahmati, clayton shepard, lin zhong, conference on human factors in computing systems 2012 2011: “playing with tactile feedback latency in touchscreen interaction: two approaches” (pdf), topi kaaresoja, eve hoggan, emilia anttila, human-computer interaction: interact 2011 (al) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top