skip to main content making sense out of node writing coding speaking about guests search march 14, 2020 · ~4 minutes my partner has started getting into test automation and has had fun playing with cypress, backstop and faker recently. however, the whole node/npm/npx jargon was very obscure to them, so i wrote the little beginner’s guide you can find below. the jargon node: node (or node.js) is a “runtime environment”. it’s a server-side environment that runs javascript code. the same way your browser has a javascript engine, well node has one as well. this allows you to execute javascript code, like scripts, outside of a browser environment. npm: npm is the package manager for node (despite claims it doesn’t stand for “node package manager”). all languages have a package manager (java has maven, php has composer, ruby has rubygems, etc.). npm allows you to manage node dependencies (packages), such as installing and removing them. npm comes bundled with node by default, so you don’t have to install it yourself. packages: packages are versioned little bundles of code that people write and publish for other to use. cypress and faker, amongst many many others, are packages (and big ones at that). npx: npx is another command-line utility provided by npm. it’s a bit of an all-in-one command to execute the binary (see below) of the given package name. it will try within the local project if installed, or globally on your machine if installed, or it will temporarily install it otherwise. managing dependencies when you want to use a package, such as cypress or faker, you need to install it. there are two ways to do that: you can install it globally on your machine (with the -g option) which is usually discouraged because a little obscure and not very manageable. or you can install locally for your project. this is the recommended option. when you do npm install <package> in a directory that has a package.json file, it will do 3 things: it will add a line inside your package.json file to note that the package you just installed is now a dependency of your project. that means your project relies on it. it will add the package’s code, as well as the code of all the dependencies of that package (and their dependencies, and so on and so forth) into a directory called node_modules. this automatically-generated directory contains the source code of all the dependencies of your project. it is usually listed in .gitignore so that it doesn’t get committed (as it’s freaking huge and not your own code). you can safely delete this directory and reinstall all the dependencies of your project with npm install at any time. “have you tried reinstalling your node_modules?” is basically the debug-101 of projects using node. 😅 it will generate (or update) a file called package-lock.json. this is an automatically generated file that should never be updated by hand. it contains the version of all your dependencies (as well as their dependencies, and the dependencies of your dependencies, and so on and so forth). this file is a manifest that makes it possible for someone to come after you (or yourself), run npm install, and have the exact same packages as you did. think of it as a snapshot of all your project’s dependencies. using dependencies alright, so let’s recap a little bit what we just learnt. node is an environment to execute javascript code. it has a package manager called npm, which is used to install (and reinstall) packages. a project usually has dependencies, because not everything should be coded from scratch. these dependencies are installed through npm, and listed in the package.json file. when installed, their code is in node_modules. okay, so now that we have dependencies installed for our project, how do we use them? well, that depends what these dependencies do. let’s take two different examples: cypress and faker. cypress is a tool. it gives you commands like cypress open and cypress run. that’s what we call a “binary”. basically it means it gives you something you can execute from your terminal. this executable is exposed by cypress in the node_modules/.bin folder. any package that provides an executable will be located in that folder. that’s why you can run ./node_modules/.bin/cypress (or $(npm bin)/cypress which is the exact same thing). faker, on the other hand, does not provide an executable. it gives you javascript utilities you can import in your javascript code. you import that dependency doing import faker from 'faker' in your javascript files. node can magically resolve from 'faker' by going into node_modules/faker and finding the relevant files. that’s pretty handy so you don’t have to do import faker from './node_modules/faker/lib/something/specific/to/faker/index.js. wrapping up alright, so let’s sum up what we just learnt: some packages provide executables, some don’t. all packages providing an executable can be executed with ./node_modules/.bin/<package>. most packages do not provide a command-line executable, and are made to be imported within a javascript file. this can be done with import something from '<package>'. what is being imported depends on the package and can be figured out by reading its documentation. i hope this helps! read previous post: lessons from building “n26 for web” read next post: account handling with cypress © 2012-2020 hugo giraudel rss github twitter