skip to main content css-tricks articles videos almanac snippets newsletter jobs guides back to top contact about archives advertise jobs license subscribe forums guest posting facebook twitter youtube instagram rss search for: search open search open navigation home / articles / practical css scroll snapping author max kohler 10 comments go to comments last updated mar 23, 2020 scroll-snap scrolling personalized marketing with mailchimp css scroll snapping allows you to lock the viewport to certain elements or locations after a user has finished scrolling. it’s great for building interactions like this one: live demo browser support and basic usage browser support for css scroll snapping has improved significantly since it was introduced in 2016, with google chrome (69+), firefox, edge, and safari all supporting some version of it. this browser support data is from caniuse, which has more detail. a number indicates that browser supports the feature at that version and up. desktop chrome firefox ie edge safari 69 68 11* 79 11 mobile / tablet android chrome android firefox android ios safari 80 68 80 11.0-11.2 scroll snapping is used by setting the scroll-snap-type property on a container element and the scroll-snap-align property on elements inside it. when the container element is scrolled, it will snap to the child elements you’ve defined. in its most basic form, it looks like this: <div class="container">
  <section class="child"></section>
  <section class="child"></section>
  <section class="child"></section>
  <p>...</p>
</div> .container {
  scroll-snap-type: y mandatory;
}

.child {
  scroll-snap-align: start;
} this is different to the first version of the spec, which allowed you to set snap-points manually using the repeat keyword: .container {
  /* old */
  scroll-snap-points-y: repeat(300px);
} this method is pretty limited. since it only allows evenly-spaced snap points, you can’t really build an interface that snaps to different-sized elements. if elements change their shape across different screen sizes, you’re also bound to run into issues. at the time of this writing, firefox, internet explorer, and edge support the older version of the spec, while chrome (69+) and safari support the newer, element-based method. you can use both methods alongside each other (if your layout allows it) to support both groups of browsers: .container {
  scroll-snap-type: mandatory;
  scroll-snap-points-y: repeat(300px);
  scroll-snap-type: y mandatory;
}

.child {
  scroll-snap-align: start;
} i’d argue a more flexible option is to use the element-based syntax exclusively and loading a polyfill to support browsers that don’t yet support it. this is the method i’m using in the examples below. unfortunately, the polyfill doesn't come with a browser bundle, so it's a bit tricky to use if you're not using a build process. the easiest way around this i've found is to link to the script on bundle.run and initializing it using cssscrollsnappolyfill() once the dom is loaded. it’s also worth pointing out that this polyfill only supports the element-based syntax, not the repeat-method. parent container properties as with any property, it’s a good idea to get familiar with the values they accept. scroll snap properties are applied to both parent and child elements, with specific values for each. sort of the same way flexbox and grid do, where the parent becomes a "flex" or "grid" container. in this case, the parent becomes a snap container, if you will. here are the properties and values for the parent container and how they work. scroll-snap-type “mandatory” vs. “proximity” the mandatory value means the browser has to snap to a snap point whenever the user stops scrolling. the proximity property is less strict—it means the browser may snap to a snap point if it seems appropriate. in my experience, this tends to kick in when you stop scrolling within a few hundred pixels of a snap point. codepen embed fallback in my own work, i’ve found that mandatory makes for a more consistent user experience, but it can also be dangerous, as the spec points out. picture a scenario where an element inside a scrolling container is taller than the viewport: if that container is set to scroll-snap-type: mandatory, it will always snap either to the top of the element or the top of the one below, making the middle part of the tall element impossible to scroll to. scroll-padding by default, content will snap to the very edges of the container. you can change that by setting the scroll-padding property on the container. it follows the same syntax as the regular padding property. this can be useful if your layout has elements that could get in the way of the content, like a fixed header. properties on the children now let’s move on over to the properties for child elements. scroll-snap-align this lets you specify which part of the element is supposed to snap to the container. it has three possible values: start, center, and end. these are relative to the scroll direction. if you’re scrolling vertically, start refers to the top edge of the element. if you’re scrolling horizontally, it refers to the left edge. center and end follow the same principle. you can set a different value for each scroll direction separated by a space. scroll-snap-stop “normal” vs. “always” by default, scroll snapping only kicks in when the user stops scrolling, meaning they can skip over several snap points before coming to a stop. you can change this by setting scroll-snap-stop: always on any child element. this forces the scroll container to stop on that element before the user can continue to scroll. at the time of this writing, no browser supports scroll-snap-stop natively, though there is a tracking bug for chrome. let’s look at some examples of scroll snap in use. example 1: vertical list to make a vertical list snap to each list element only takes a few lines of css. first, we tell the container to snap along its vertical axis: .container {
  scroll-snap-type: y mandatory;
} then, we define the snap points. here, we're specifying that the top of each list element is going to be a snap point: .child {
  scroll-snap-align: start;
} codepen embed fallback example 2: horizontal slider to make a horizontal slider, we tell the container to snap along its x-axis. we’re also using scroll-padding to make sure the child elements snap to the center of the container. .container {
  scroll-snap-type: x mandatory;
  scroll-padding: 50%;
} then, we tell the container which points to snap to. to center the gallery, we define the center point of each element as a snap point. .child {
  scroll-snap-align: center;
} codepen embed fallback example 3: vertical full screen we can set the snap points directly on the element: html { /* body won't work ¯\_(ツ)_/¯ */
  scroll-snap-type: y mandatory;
} then, we make each section the size of the viewport and define the top edge as a snap point: section {
  height: 100vh;
  width: 100vw;
  scroll-snap-align: start;
} codepen embed fallback example 4: horizontal full screen this is the same sort of concept as the vertical version, but with the snap point on the x-axis instead. body {
  scroll-snap-type: x mandatory;
}

section {
  height: 100vh;
  width: 100vw;
  scroll-snap-align: start;
} codepen embed fallback example 5: 2d image grid scroll snapping can work in two directions at the same time. again, we can set scroll-snap-type directly on the element: .container {
  scroll-snap-type: both mandatory;
} then, we define the top-left corner of each tile as a snap point: .tile {
  scroll-snap-align: start;
} codepen embed fallback some thoughts on user experience messing with scrolling is risky business. since it’s such a fundamental part of interacting with the web, changing it in any way can feel jarring—the term scrolljacking used to get thrown around to describe that sort of experience. the great thing about css-based scroll snapping is that you're not taking direct control over the scroll position. instead, you're just giving the browser a list of positions to snap in a way that is appropriate to the platform, input method, and user preferences. this means a scrolling interface you build is going to feel just like the native interface (i.e using the same animations, etc.) on whatever platform it's viewed on. to me, this is the key advantage of css scroll snapping over javascript libraries that offer similar functionality. this works fairly well in my experience, especially on mobile. maybe this is because scroll snapping is already part of the native ui on mobile platforms. (picture the home screens on ios and android—they’re essentially horizontal sliders with snap points.) the interaction on chrome on android is particularly nice because it feels like regular scrolling, but the viewport always happens to come to a stop at a snap point: there’s definitely some fancy maths going on to make this happen. thanks to css scroll snapping, we’re getting it for free. of course, we shouldn’t start throwing snap points onto everything. things like article pages do just fine without them. but i think they can be a nice enhancement in the right situation—image galleries, slideshows seem like good candidates, but maybe there’s potential beyond that. conclusion if done thoughtfully, scroll snapping can be a useful design tool. css snap points allow you to hook into the browser’s native scrolling interaction, so your interface feel seamless and smooth. with a javascript api potentially on the horizon, these are going to become even more powerful. still, a light touch is probably the way to go. our learning partner need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. comments greg perham permalink to comment# august 16, 2018 user experience for this on mobile is still pretty bad. playing with the demos above had plenty of unexpected behavior, such as not being able to scroll past some elements and jumping to seemingly arbitrary points. where it does work, it’s kinda neat. sam permalink to comment# august 16, 2018 demos don’t work in safari ios 11.3. brant ward permalink to comment# august 16, 2018 webkit prefixes should fix this. maxart permalink to comment# september 18, 2018 @brant no they don’t. safari 11 should support it unprefixed. older versions used prefixes. it looks like safari just seems to support scroll snap, but it really doesn’t. i really couldn’t manage to make the demos work, couldn’t even be able to make an un-polyfilled demo to work. no problem in chrome or desktop safari. albin permalink to comment# august 16, 2018 this works in opera to since quite a few versions back :-) daniel tonon permalink to comment# august 16, 2018 thanks for writing this. with support finally coming to chrome, it’s feasible that we can start using this now. i was hoping someone would write a blog post about how to achieve x-browser scroll-snap support and now it exists. gregor permalink to comment# august 24, 2018 it might feel differently on a mobile device, but trying out the demos on my laptop made me really mad. it doesn’t feel natural at all and i had trouble to navigate to the point i wanted. if would have such an experience on a live website, i wouldn’t visit that site ever again. so i guess your warning there is pretty important. if you mess with people’s scrolling, you should be a 100% sure about what your’re doing. very interesting article though. jonathan roden (@sqth) permalink to comment# august 27, 2018 the technology is very interresting, and when well applied, can be useful to the user. but so far, such scroll-jacking is a nightmare usability. you may apply, but never remove the control of the user. brian permalink to comment# august 28, 2018 support is not yet good enough yet. your picture shows chrome 69 support, but as of aug 2018, v 69 has only 0.04% usage. chrome 67 has 23% worldwide usage, but has no scroll snap support steve permalink to comment# september 21, 2018 i was playing with the example 4: horizontal full screen in codepen on firefox 60.2.0esr and it works great, but when i paste all the code to a html file it no longer works. what else do you need? this comment thread is closed. if you have important information to share, please contact us. related how do you stay up to date in this fast⁠-⁠moving industry? a good start is to sign up for our weekly hand-written newsletter. we bring you the best articles and ideas from around the web, and what we think about them. email address subscribe facebook @csstricks twitter @css youtube @realcsstricks instagram @real_css_tricks rss feed css-tricks* is created, written by, and maintained by chris coyier and a team of swell people. the tech stack for this site is fairly boring. that's a good thing! i've used wordpress since day one all the way up to v17, a decision i'm very happy with. i also leverage jetpack for extra functionality and local for local development. *may or may not contain any actual "css" or "tricks". other nav contact about guest writing jobs advertise license subscribe all authors codepen codepen is a place to experiment, debug, and show off your html, css, and javascript creations. flywheel logo flywheel css-tricks is hosted by flywheel, the best wordpress hosting in the business, with a local development tool to match. shoptalk is a podcast all about front-end web design and development. css-tricks presents 📅 upcoming front-end conferences css-tricks presents the power of serverless for front-end developers