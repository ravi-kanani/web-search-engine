skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author jonas is the co-founder of keycdn. he’s passionate about making the web faster and more secure. interested in web technologies and open source projects. more about jonas krummenacher … october 26, 2017 leave a comment quick wins for improving performance and security of your website 19 min read performance, security share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → when it comes to building and maintaining a website, one has to take a ton of things into consideration. all webmasters should strive for a) improving the performance of their website, and b) increasing their website’s security. improving the performance of their website, increasing their website’s security. both of these goals are vital in order to run a successful website. so, we’ve put together a list of five technologies you should consider implementing to improve both the performance and security of your website. here’s a quick overview of the topics we’ll cover: let’s encrypt (ssl) a free way to obtain an ssl certificate for improved security and better performance. http/2 the successor to the http 1.1 protocol, which introduces many performance enhancements. brotli compression. a compression method that outperforms gzip, resulting in smaller file sizes. webp images. an image format that renders images smaller than a typical jpeg or png, resulting in faster loading times. content delivery network. a collection of servers spread out across the globe, with the aim of caching and delivering your website’s assets faster. if you aren’t aware of the benefits of improving your website’s performance and security, consider the fact that google loves speed and, since 2010, has been using website speed as a ranking factor. furthermore, if you run an e-commerce shop or a simple blog with an opt-in form, a faster website will increase your conversions. according to a study by mobify, for every 100-millisecond decrease in home-page loading speed, mobify saw a 1.11% lift in session-based conversions for its customer base, amounting to an average annual revenue increase of $376,789. the web is also quickly moving towards ssl to provide users with better security and improved overall performance. in fact, for a couple of the technologies mentioned in this article, having an ssl-enabled website is a prerequisite. before jumping in, note that even if you can’t (or decide not to) apply each and every one of the suggestions mentioned here, your website would still benefit from implementing any number of the methods outlined. therefore, try to determine which aspects of your website could use improvement and apply the suggestions below accordingly. let’s encrypt (ssl) if your website is still being delivered over http, it’s time to migrate now. google already takes https into consideration as a ranking signal and according to google’s security blog, all non-secure web pages will eventually display a dominant “not secure” message within the chrome browser. that’s why, to start off this list, we’ll go over how you can complete the migration process with a free ssl certificate, via let’s encrypt. let’s encrypt is a free and automated way to obtain an ssl certificate. before let’s encrypt, you were required to purchase a valid certificate from a certificate-issuing authority if you wanted to deliver your website over https. due to the additional cost, many web developers opted not to purchase the certificate and, therefore, continued serving their website over http. however, since let’s encrypt’s public beta launched in late 2015, millions of free ssl certificates have been issued. in fact, let’s encrypt stated that, as of late june 2017, over 100 million certificates have been issued. before let’s encrypt launched, fewer than 40% of web pages were delivered over https. a little over a year and a half after the launch of let’s encrypt, that number has risen to 58%. if you haven’t already moved to https, do so as soon as possible. here are a few reasons why moving to https is beneficial: increased security (because everything is encrypted), https is required in order for http/2 and brotli to work, https is a ranking signal, ssl-secured websites build visitor trust. how to obtain a let’s encrypt certificate you can obtain an ssl certificate in a few ways. although the ssl certificates that let’s encrypt provides satisfy most use cases, there are certain things to be aware of: there is currently no option for wildcard certificates. however, this is planned to be supported in january 2018. let’s encrypt certificates are valid for a period of 90 days. you must either renew them manually before they expire or set up a process to renew them automatically. of course, if one or both of these points are a deal-breaker, then acquiring a custom ssl certificate from a certificate authority is your next best bet. regardless of which provider you choose, having an https-enabled website should be your top priority. to obtain a let’s encrypt certificate, you have two methods to choose from: with shell access: run the installation and obtain a certificate yourself. without shell access: obtain a certificate through your hosting or cdn provider. the second option is pretty straightforward. if your web host or cdn provider offers let’s encrypt support, you basically just need to enable it in order to start delivering assets over https. however, if you have shell access and want or need to configure let’s encrypt yourself, then you’ll need to determine which web server and operating system you’re using. next, go to certbot and select your software and system from the dropdown menus to find your specific installation instructions. although the instructions for each combination of software and os are different, certbot provides simple setup instructions for a wide variety of systems. certbot home page (view large version) http/2 thanks to let’s encrypt (or any other ssl certificate authority), your website should now be running over https. this means you can now take advantage of the next two technologies we’ll discuss, which would otherwise be incompatible if your website was delivered over http. the second technology we’ll cover is http/2. http 1.1 was released more than 15 years ago, and since then some major improvements have occurred. one of the most welcome improvements of http/2 is that it allows browsers to parallelize multiple downloads using only one connection. with http 1.1, most browsers were able to handle only six concurrent downloads on average. http/2 now renders methods such as domain-sharding obsolete. apart from requiring only one connection per origin and allowing multiple requests at the same time (multiplexing), http/2 offers other benefits: server push. pushes additional resources that it thinks the client will require in the future. header compression. reduces the size of headers by using hpack header compression. binary. unlike in http 1.1, which was textual, binary reduces the time required to translate text to binary and makes it easier for a server to parse. prioritization. priority levels are associated with requests, thereby allowing resources of higher importance to be delivered first. enabling http/2 regardless of how you’re delivering the majority of your content, whether from your origin server or a cdn, most providers now support http/2. determining whether a provider supports http/2 should be fairly easy by going to its features page and checking around. as for cdn providers, is tls fast yet? provides a comprehensive list of cdn services and marks whether they support http/2. if you want to check for yourself whether your website currently uses http/2, then you’ll need to get the latest version of curl and run the following command: curl --http2 http://yourwebsite.com alternatively, if you’re not comfortable using the command line, you can open up chrome’s developer tools and navigate to the “network” tab. under the “protocol” column, you should see the value h2. chrome's developer tools h2 (view large version) enabling http/2 on nginx if you’re running your own server and are using an outdated software version, then you’ll need to upgrade it to a version that supports http/2. for nginx users, the process is pretty straightforward. simply ensure that you’re running nginx version 1.9.5 or higher, and add the following listen directive within the server block of your configuration file: listen 443 ssl http2; enabling http/2 on apache for apache users, the process involves a few more steps. apache users must update their system to version 2.4.17 or higher in order to make use of http/2. they’ll also need to build https with the mod_http2 apache module, load the module, and then define the proper server configuration. an outline of how to configure http/2 on an apache server can be found in the apache http/2 guide. no matter which web server you’re using, your website will need to be running on https in order to take advantage of the benefits of http/2. http/2 vs. http 1.1: performance test you can test the performance of http/2 compared to http 1.1 manually by running an online speed test before and after enabling http/2 or by checking your browser’s development console. based on the structure and number of assets that your website loads, you might experience different levels of improvement. for instance, a website with a large number of resources will require multiple connections over http 1.1 (thus increasing the number of round trips required), whereas on http/2 it will require only one. the results below are the findings for a default wordpress installation using the 2017 theme and loading 18 image assets. each setup was tested three times on a 100 mbps connection, and the average overall loading time was used as the final result. firefox was used to examine the waterfall structure of these tests. the first test below shows the results over http 1.1. in total, the entire page took an average of 1.73 seconds to fully load, and various lengths of blocked time were incurred (as seen by the red bars). http 1.1 loading time and waterfall (view large version) when testing the exact same website, only this time over http/2, the results were quite different. using http/2, the average loading time of the entire page took 1.40 seconds, and the amount of blocked time incurred was negligible. http/2 loading time and waterfall (view large version) just by switching to http/2, the average savings in loading time ended up being 330 milliseconds. that being said, the more resources your website loads, the more connections must be made. so, if your website loads a lot of resources, then implementing http/2 is a must. 3. brotli compression the third technology is brotli, a compression algorithm developed by google back in 2015. brotli continues to grow in popularity, and currently all popular web browsers support it (with the exception of internet explorer). compared to gzip, brotli still has some catching up to do in global availability (i.e. in cms plugins, server support, cdn support, etc.). however, brotli has shown some impressive compression results compared to other methods. for instance, according to google’s algorithm study, brotli outperformed zopfli (another modern compression method) by 20 to 26% in compression ratio. enabling brotli depending on which web server you’re running, implementation of brotli will be different. you’ll need to use the method appropriate to your setup. if you’re using nginx, apache or microsoft iis, then the following modules are available to enable brotli. ngx_brotli, nginx module mod_brotli, apache module iis brotli, microsoft iis community-contributed extension once you’ve finished downloading and installing one of the modules above, you’ll need to configure the directives to your liking. when doing this, pay attention to three things: file type. the types of files that can be compressed with brotli include css, javascript, xml and html. compression quality. the quality of compression will depend on the amount of compression you want to achieve in exchange for time. the higher the compression level, the more time and resources will be required, but the greater the savings in size. brotli’s compression value can be defined anywhere from 1 to 11. static versus dynamic compression. the stage at which you would like brotli compression to take place will determine whether to implement static or dynamic compression: static compression pre-compresses assets ahead of time — before the user actually makes a request. therefore, once the request is made, there is no need for brotli to compress the asset — it will already have been compressed and, hence, can be served immediately. this feature comes built-in with the nginx brotli module, whereas implementing static compression with apache requires some configuration. dynamic compression occurs on the fly. in other words, once a visitor makes a request for a brotli-compressible asset, the asset is compressed on the spot and subsequently delivered. this is useful for dynamic content that needs to be compressed upon each request, the downside being that the user must wait for the asset to be compressed before it is delivered. a brotli configuration for nginx users might look similar to the snippet below. this example sets compression to occur dynamically (on the fly), defines a quality level of 5 and specifies various file types. brotli on;
brotli_comp_level 5;
brotli_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript; to verify that brotli is enabled on your server, you can open up chrome’s developer tools, navigate to the “network” tab, select an asset, and check the content-encoding header. this should now be br. note that brotli requires https, so if you’ve correctly gone through the installation and configuration process but still don’t see the br value, then you’ll need to migrate to https. chrome's developer tools br (view large version) otherwise, you can run a simple curl command, such as: curl -i https://yourwebsite.com/path/to/your/asset.js this will return a list of response headers, where you can also check for the content-encoding header value. if you're using wordpress and want to take things a step further by delivering a brotli-compressed html document, check out my wordpress guide to brotli to learn how. brotli vs. gzip: performance test to compare brotli and gzip compression, we'll take three compressible web assets and compare them in size and loading speed. both compression methods were defined with a level 5 compression value. having tested the assets three times and taking the average loading speed of each, the results were as follows: asset name gzip size gzip loading time brotli size brotli loading time jquery.js 33.4 kb 308 ms 32.3 kb 273 ms dashicons.min.css 28.1 kb 148 ms 27.9 kb 132 ms style.css 15.7 kb 305 ms 14.5 kb 271 ms overall, the gzipped assets were 77.2 kb in total size, while the brotli assets were 74.7 kb. that's a 3.3% reduction in overall page size just from using brotli compression on three assets. as for loading time, the gzip assets had a combined total time of 761 milliseconds, while the brotli assets took 676 milliseconds to load — an improvement of 12.6%. 4. webp images our fourth suggestion is to use the image format that goes by the name of webp. like brotli, webp was developed by google for the purpose of making images smaller. like jpeg and png, webp is an image format. the primary advantage of serving webp images is that they are much smaller in size than jpegs and pngs. typically, savings of up to 80% can be achieved after converting a jpeg or png to webp. the downside of the webp image format is that not all browsers support it. at the time of writing, only chrome and opera do. however, with proper configuration, you can deliver webp images to supporting browsers, while delivering a fallback image format (such as jpeg) to non-supporting browsers. webp still has a way to go before becoming as widespread as jpeg and png. however, thanks to its impressive savings in size, it stands a good chance of continued growth. overall, webp reduces total page size, speeds up website loading and saves bandwidth. how to convert to and deliver webp a few options are available to convert images to webp format. if you use a popular cms such as wordpress, joomla or magento, plugins are available that enable you to convert images directly within the cms’ dashboard. on the other hand, if you want to take a manual approach, online webp image converters are available, and certain image-processing apps even come with a webp format option that you can export to, thereby saving you from having to convert anything at all. lastly, if you prefer a more integrated approach, certain image-processing services provide an api that you can use to integrate directly in your web project, enabling you to convert images automatically. as mentioned, not all browsers currently support webp images. therefore, if you serve an image on your website with only a .webp extension, non-supporting browsers will return a broken image. that's why a fallback is important. let's go over three ways to achieve this. 1. use the picture element this method allows you to define the path of a webp image, as well as the path of the original jpeg within the website's html. with this method, supporting browsers will display the webp images, while all other browsers will display the default image defined in the last nested child tag within the picture block. consider the following example: <picture>
    <source srcset="images/my-webp-image.webp" type="image/webp">
    <img src="images/my-jpg-image.jpg" alt="my image">
</picture> this method implements webp functionality most widely, while ensuring that a fallback mechanism is in place. however, it might require a lot of modification to the html, depending on how large your application is. 2. modify the server's config file this method uses rewrite rules defined in the server's config file to fall back to a supported image format if the browser doesn't support webp. use the appropriate snippet for apache or nginx according to your web server, and adjust the path/images directory accordingly. for apache: rewriteengine on
rewritecond %{http_accept} image/webp
rewritecond %{document_root}/$1.webp -f
rewriterule ^(path/images.+)\.(jpe?g|png)$ $1.webp [t=image/webp,e=accept:1]

header append vary accept env=redirect_accept
addtype image/webp .webp for nginx: # http config block
map $http_accept $webp_ext {
    default "";
    "~*webp" ".webp";
}

# server config block
location ~* ^(path/images.+)\.(png|jpg)$ {
    add_header vary accept;
    try_files $1$webp_ext $uri =404;
} the downside of this method is that it is not recommended if you are going to be using webp images in conjunction with a cdn. the reason is that the cdn will cache a webp image if a webp-supported browser is the first one to request the asset. therefore, any subsequent requests will return the webp image, whether the browser supports it or not. 3. use a wordpress caching plugin if you're a wordpress user and need a solution that will deliver webp images to supporting browsers while falling back to jpegs and pngs for others, all the while being compatible with a cdn, then you can use a caching plugin such as cache enabler. if you define within the plugin that you want to create an additional cached version for webp, then the plugin will deliver a webp-cached version to supporting browsers, while falling back to html or html gzip for other browsers. webp vs. jpeg: performance tests to demonstrate the difference in size between a webp and jpeg image, we'll take three jpeg images, convert them to webp, and compare the output to the originals. the three images are shown below and carry a size of 2.1 mb, 4.3 mb and 3.3 mb, respectively. test jpeg image 1 (view large version) test jpeg image 2 (view large version) test jpeg image 3 (view large version) when converted to webp format, each image reduced significantly in size. the table below outlines the sizes of the original images, the sizes of the webp versions, and how much smaller the webp images are than the jpegs. the images were converted to webp using lossy compression, with a quality level of 80. image name jpeg size webp size percentage smaller test-jpg-1 2.1 mb 1.1 mb 48% test-jpg-2 4.3 mb 1 mb 77% test-jpg-3 3.3 mb 447 kb 85.9% you can compress webp images using either a lossless (i.e. no quality loss) or lossy (i.e. some quality loss) method. the tradeoff for quality is a smaller image size. if you want to implement lossy compression for additional savings in size, doing so with webp will render a better quality picture at a smaller size, as opposed to a lossy jpeg at the same level of quality. david walsh has written a comprehensive post outlining the size and quality differences between webp, jpeg and png. 5. content delivery network the last suggestion is to use a content delivery network (cdn). a cdn accelerates web assets globally by caching them across a cluster of servers. when a website uses a cdn, it essentially offloads the majority of its traffic to the cdn's edge servers and routes its visitors to the nearest cdn server. cdns store a website's resources for a predefined period of time thanks to caching. with caching, a cdn's server creates a copy of the origin server's web asset and store it on its own server. this process makes web requests much more efficient, given that visitors will be accessing your website from multiple geographic regions. if no cdn has been configured, then all of your visitors' requests will go to the origin server's location, wherever that may be. this creates additional latency, especially for visitors who are requesting assets from a location far away from the origin server. however, with a cdn configured, visitors will be routed to the cdn provider's nearest edge server to obtain the requested resources, thus minimizing request and response times. setting up a cdn the process for setting up a cdn will vary according to the cms or framework you're using. however, at a high level, the process is more or less the same: create a cdn zone that points to your origin url (https://yourwebsite.com). create a cname record to point a custom cdn url (cdn.yourwebsite.com) to the url provided by your cdn service. use your custom cdn url to integrate the cdn with your website (make sure to follow the guide appropriate to your website's setup). check your website's html to verify that the static assets are being called using the cdn's url that you defined and not the origin url. once this is complete, you'll be delivering your website's static assets from the cdn's edge servers instead of your own. this will not only improve website speed, but will also enhance security, reduce the load on your origin server and increase redundancy. before and after using a cdn: performance test because a cdn, by nature, has multiple server locations, performance tests will vary according to where you are requesting an asset from and where the cdn's closest server is. therefore, for the sake of simplicity, we'll choose three locations from which to perform our tests: frankfurt, germany new york, united states toronto, canada. as for the assets to be tested, we chose to measure the loading times of an image, a css file and a javascript file. the results of each test, both with and without a cdn enabled, are outlined in the table below: frankfurt, germany new york, united states toronto, canada image, no cdn 222 ms 757 ms 764 ms image, with cdn 32 ms 81 ms 236 ms javascript file, no cdn 90 ms 441 ms 560 ms javascript file, with cdn 30 ms 68 ms 171 ms css file, no cdn 96 ms 481 ms 553 ms css file, with cdn 31 ms 77 ms 148 ms in all cases, the loading times for assets loaded through a cdn were faster than without a cdn. results will vary according to the location of the cdn and your visitors; however, in general, performance should be boosted. conclusion if you're looking for ways to increase your website's performance and security, these five methods are all great options. not only are they all relatively easy to implement, but they'll also modernize your overall stack. some of these technologies are still in the process of being globally adopted (in terms of browser support, plugin support, etc.); however, as demand increases, so will compatibility. thankfully, there are ways to implement some of the technologies (such as brotli and webp images) for browsers that support them, while falling back to older methods for browsers that do not. as a final note, if you haven't already migrated your website to https, do so as soon as possible. https is now the standard and is required in order to use certain technologies, such as http/2 and brotli. your website will be more secure overall, will perform faster (thanks to http/2) and will look better in the eyes of google. (rb, vf, yk, al, il) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top