skip to main content css-tricks articles videos almanac snippets newsletter jobs guides back to top contact about archives advertise jobs license subscribe forums guest posting facebook twitter youtube instagram rss search for: search open search open navigation home / articles / responsive grid magazine layout in just 20 lines of css author keir watson 13 comments join conversation last updated mar 3, 2020 grid grid-template-columns personalized marketing with mailchimp i was recently working on a modern take of the blogroll. the idea was to offer readers a selection of latest posts from those blogs in a magazine-style layout, instead of just popping a list of our favorite blogs in the sidebar. the easy part was grabbing a list of posts with excerpts from our favorite rss feeds. for that, we used a wordpress plugin, feedzy lite, which can aggregate multiple feeds into a single time-ordered list ‚Äî perfect for showcasing their latest offerings. the hard part was making it all look awesome. the plugin‚Äôs default list ui is rather bland, so i wanted to style it to look like a newspaper or magazine website with a mixture of smaller and larger ‚Äúfeatured content‚Äù panels. this seems like an ideal case for css grid! create a grid layout for different layouts, say, one five-column layout and one three-column layout, then use media queries to switch between them at different break points. right? but do we actually need those media queries ‚Äî and all the hassle of identifying break points ‚Äî when we can use grid‚Äôs auto-fit options to automatically create a fluid responsive grid for us? the approach sounded tempting, but when i started introducing column-spanning elements, i ran into trouble with the grid overflowing on narrow screens. media queries appeared to be the only solution. that is, until i found a workaround! after looking at several tutorials on css grid, i found that they largely fall into two camps: tutorials that show you how to create an interesting layout with spanned elements, but for a fixed number of columns. tutorials that explain how to make a responsive grid that resizes automatically, but with all of the grid items the same width (i.e. without any spanned columns). i want to make the grid do both: create a fully responsive fluid layout that includes responsively resizing multi-column elements as well. the beauty is that once you understand the limitations of responsive grids, and why and when column spans break grid responsiveness, it is possible to define a responsive magazine/news style layout in just a dozen lines of code plus one simple media query (or even with no media queries if you are willing to limit your span options). here‚Äôs a visual showing the rss plugin right out of the box and what it‚Äôll look like after we style it up. (demo) this magazine-style grid layout is fully responsive with the colored featured panels adjusting dynamically as the number of columns change. the page displays around 50 posts, but the layout code is agnostic as to the number of items displayed. ramp up the plugin to show 100 items and the layout stays interesting all the way down. all of this is achieved using only css and with only a single media query to deal with a single column display on the narrowest of screens (i.e. smaller than 460px). incredibly, this layout only took 21 lines of css (excluding global content styling). however, to achieve such flexibility in such a few lines of code, i had to dig deep into the more obscure parts of some of css grid and learn how to work around some of its inherent limitations. the essential elements of the code that produce this layout is incredibly short and a testament to the awesomeness of css grid: .archive {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
  grid-gap: 32px;
  grid-auto-flow: dense;
}

/* extra-wide grid-posts */
.article:nth-child(31n + 1) {
  grid-column: 1 / -1;
}
.article:nth-child(16n + 2) {
  grid-column: -3 / -1;
}
.article:nth-child(16n + 10) {
  grid-column: 1 / -2;
}

/* single column display for phones */
@media (max-width: 459px) {
  .archive {
    display: flex;
    flex-direction: column;
  }
} the techniques in this article could be used equally well to style any dynamically generated content such as the output from a latest posts widget, archive pages or search results. creating a responsive grid i have set up seventeen items displaying a variety of mock content ‚Äî headlines, images and excerpts ‚Äî which are all contained in a wrapper <div class="archive">
  <article class="article">
    <!-- content -->
  </article>
  
  <!-- 16 more articles -->
  
</div> the code that turns these items into a responsive grid is remarkably compact: .archive {
  /* define the element as a grid container */
  display: grid;
  /* auto-fit as many items on a row as possible without going under 180px */
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  /* a little spacing between articles */
  grid-gap: 1em;
} codepen embed fallback notice how the heights of the rows automatically adjust to accommodate the tallest content in the row. if you change the width of the pen, you will see the items grow and shrink fluidly and the number of columns change from one to five, respectively. the css grid magic at play here is the auto-fit keyword that works hand-in-hand with the minmax() function that‚Äôs applied to grid-template-columns. how it works we could have achieved the five-column layout alone using this: .archive {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
} however, this would create five columns that grow and shrink with different screen widths, but always stay at five columns, resulting in them becoming ridiculously narrow on small screens. the first thought might be to create a bunch of media queries and redefine the grid with different numbers of columns. that would work fine, but with the auto-fit keyword, it is all done automatically. for auto-fit to work the way we want, we need to use the minmax() function. this tells the browser how small the columns can be squeezed down to followed by the maximum width they can expand to. any smaller, and it will automatically reduce the number of columns. any larger, and the number of columns increases. .archive {
  grid-template-columns: repeat (auto-fit, minmax(180px, 1fr));
} in this example, the browser will fit in as many columns as it can 180px wide. if there is space left over the columns will all grow equally by sharing the remaining space between them ‚Äî that‚Äôs what the 1fr value is saying: make the columns equal fractions of the available width. drag the window out and as the available space increases the columns all grow equally to use up any additional space. the columns will keep growing until the available space allows for an additional 180px column, at which point a whole new column appears. decrease the screen width, and the process reverses, perfectly adjusting the grid all the way down to a single column layout. magic! and you get all this responsiveness out of just one line of code. how cool is that? creating spans with ‚Äúautoflow: dense‚Äù so far, we have a responsive grid but all items the same width. for a news or magazine layout we need some content to be featured by spanning two or more columns or even, perhaps, to span all the columns. to create multi-column spans we can add the column-span feature to the grid items we want to take up more space. for example, if we want the third item in our list to be two columns wide we can add: .article:nth-child(3) {
  grid-column: span 2;
} however, once we start adding spans a number of problems can arise. first, gaps may appear in the grid because a wide item may may not fit on the row, so grid auto-fit pushes it onto the next line, leaving a gap where it would have been: the easy fix is adding grid-auto-flow: dense to the grid element which tells the browser to fill in any gaps with other items, effectively making the narrower content flow around the wider items like this: note that the items are now out of order, with the fourth item coming before the third item, which is double the width. there is no way round this as far as i can tell, and it is one of the limitations you have to accept with css grid. check out geoff graham‚Äôs "the auto-flowing powers of grid‚Äôs dense keyword‚Äù for an introduction to grid-auto-flow: dense with examples of how it behaves. ways to specify spans there are several ways to indicate how many columns an item should span. the easiest is to apply grid-columns: span [n] to one of the items, where n is the number of columns the element will span. the third item in our layout has grid-column: span 2, which explains why it is double the width of other items that only span a single column. other methods require you to explicitly define grid lines. the numbering system for grid lines is as follows: grid lines can be specified from left-to-right using positive values (e.g. 1, 2, 3) or negative values (e.g. -1, -2, -3) to go from right-to-left. these can be used to place items on the grid using the grid-column property like this: .grid-item {
  grid-column: (start track) / (end track);
} so, this gives us additional ways to specify a spanned item. this is especially flexible as either the start or end value can be replaced with the span keyword. for example, the three-column blue box in the example above could be created by adding any of the following to the eighth grid item: grid-column: 3 / 6 grid-column: -4 / -1 grid-column: 3 / span 3 grid-column: -4 / span 3 grid-column: span 3 / -1 etc. on a non-responsive (i.e. fixed columns) grid, these all produce the same effect (like the blue box above), however, if the grid is responsive and the number of columns changes, their differences start to become apparent. certain column spans break the layout with an auto-flowing grid, making the two techniques appear incompatible. fortunately, there are some solutions which allow us to combine the two successfully. first, however, we need to understand the problem. overflow side-scrolling problems here are some featured areas created using the notation above: (demo) it all looks good at full-width (five columns) but when resized to what should be two columns, the layout breaks like this: as you can see, our grid has lost its responsiveness and, although the container has shrunk, the grid is trying to maintain all five columns. to do so, it has given up trying to keep equal-width columns, and the grid is breaking out of the right-hand side of its container, causing horizontal scrolling. why is this? the problem comes about because the browser is trying to honor the explicit grid lines we named. at this width, the auto-fit grid should implicitly be displaying two columns, but our grid line numbering system contradicts this by explicitly referring to the fifth grid line. this contradiction leads to the mess. to display our implicit two-column grid correctly, the only line numbers allowed are 1, 2 and 3 and -3, -2, -1, like this: but if any of our grid items contains grid-column references that lie outside this, such as grid line number 4, 5 or 6 (or -4, -5 or -6), the browser is getting mixed messages. on the one hand, we have asked it to automatic create flexible columns (which should implicitly give us two columns at this screen width) but we have also explicitly referred to grid lines that don‚Äôt appear in a two-column grid. when there is a conflict between implicit (automatic) columns and an explicit number of columns, grid always defers to the explicit grid; hence the unwanted columns and horizontal overflow (which has also been aptly named css data loss). just like using grid line numbers, spans can also create explicit columns. so, grid-column: span 3 (the eighth grid item in the demo) forces the grid to explicitly adopt at least three columns, whereas we want it, implicitly display two. at this point it might seem like the only way forward is to use media queries to change the grid-column values at the width where our layout breaks ‚Äî but not so fast! that‚Äôs what i assumed at first. but after thinking it though a bit more and playing around with various options, i found there are a limited set of workarounds that work all the way down to two columns, leaving just one media query to cover a single column layout for the narrowest screens. the solutions the trick, i realized, is to only specify spans using grid lines that appear in the narrowest grid you intend to display. that is a two-column grid in this case. (we will use a media query to cover the single column scenario for very narrow screens.) that means we can safely use grid lines 1, 2 and 3 (or -3, -2 and -1) without breaking the grid. i initially thought that meant limiting myself to a maximum span of two columns, using combinations of the following: grid column: span 2 grid-column: 1 /3 grid-column: -3 / -1 which remains perfectly responsive right down to two columns: although this works, it is rather limiting from a design perspective, and not particularly exciting. i wanted to be able to create spans that would be three, four or even five columns wide on large screens. but how? my first thought was that i would have to resort to media queries (omg old habits die hard!) but i was trying to get away from that approach and think differently about responsive design. taking another look at what we can do with just 1 to 3 and -3 to -1, i gradually realized that i could mix positive and negative line numbers for the grid column‚Äôs start and end values ,such as 1/-3 and 2/-2. at first glance, this does not seem very interesting. that changes when you realize where these lines are located as you resize the grid: these spanned elements change width with the screen size. this opened up a whole new set of possibilities for responsive column spans: items that will span different numbers of columns as the screen gets wider, without needing media queries. the first example i discovered is grid-column: 1/-1.this makes the item act like a full-width banner, spanning from the first to the last column at all column numbers. it even works down to one column wide! by using grid-column: 1/-2, a left-aligned nearly-full-width span could be created that would always leave a one column item to the right of it. when shrunk to two columns it would shrink responsively to a single column. surprisingly, it even works when shrunk to a single column layout. (the reason seems to be that grid will not collapse an item to zero width, so it remains one column wide, as does grid-column: 1/1.) i assumed grid-column: 2/-1 would work similarly, but aligned with the right-hand edge, and for the most part it does, except at one column display when it causes overflow. next i tried 1/-3 which worked fine on wider screen, showing at least three columns, and smaller screens, showing one column. i thought it would do something weird on a two-column grid as the first grid line is the same as the grid line with -3. to my surprise, it still displays fine as a single-column item. after a lot of playing around, i came up with eleven possible grid column values using grid line numbers from the two-column grid. surprisingly, three of these work right down to single-column layouts. seven more work down to two columns and would only need a single media query to deal with single column display. here is the full list: responsive grid-column values, showing how they display at different screen sizes in an auto-fit grid. (demo) as you can see, although this is a limited subset of every possible responsive span, there are actually a lot of possibilities. 2/-2 is interesting as it creates a centered span which works all the way down to one column! 3/-1 is least useful as it causes overflow even with two-columns. 3/-3 was a surprise. by using a variety of grid-column values from this list, it is possible to create an interesting and fully responsive layout. using a single media query for the narrowest single-column display, we have ten different grid-column span patterns to play with. the single-column media query is generally straightforward as well. the one on this final demo reverts to using flexbox at smaller screens: @media (max-width: 680px) {
  .archive {
    display: flex;
    flex-direction: column;
  }

  .article {
    margin-bottom: 2em;
  }
} here is the final grid which, as you can see, is fully responsive from one to five columns: (demo) using :nth-child() to repeat variable length displays the last trick i used to get my code down to two dozen lines was the :nth-child(n) selector which i used to style multiple items in my grid. i wanted my span styling to apply to multiple items in my feed, so that the featured post boxes appeared regularly throughout the page. to start with i used a comma-separated selector list, like this: .article:nth-child(2),
.article:nth-child(18),
.article:nth-child(34),
.article:nth-child(50)  {
  background-color: rgba(128,0,64,0.8);
  grid-column: -3 / -1;
} but i soon found this cumbersome, especially as i had to repeat this list for each child element i wanted to style within each article ‚Äî such as the title, links and so on. during prototyping, if i wanted to play around with the position of my spanned elements, i had to manually change the numbers in each of these lists, which was tedious and error-prone. that‚Äôs when i realized that i could use a powerful feature :nth-child pseudo-selector instead of a simple integer as i had used in the list above. :nth-child(n) can also take an equation, such as :nth-child(2n+ 2), which will target every second child element. here is how i used the :nth-child([formula]) to create the blue full-width panels in my grid which appear at the very top of the page, and is repeated just over half way down: .article:nth-child(31n + 1) {
  grid-column: 1 / -1;
  background: rgba(11, 111, 222, 0.5);
} the bit in the brackets (31n + 1 ) ensures that the 1st, 32nd, 63rd, etc. child is selected. the browser runs a loop starting with n=0 (in which case 31 * 0 + 1 = 1), then n=1 (31 * 1 + 1 = 32), then n=2 (31 * 2 + 1 = 63). in the last case, the browser realizes that there is no 63rd child item so it ignores that, stops looping, and applies the css to the 1st and 32nd children. i do something similar for the purple boxes which alternate down the page from right-to-left: .article:nth-child(16n + 2) {
  grid-column: -3 / -1;
  background: rgba(128, 0, 64, 0.8);
}

.article:nth-child(16n + 10) {
  grid-column: 1 / -2;
  background: rgba(128, 0, 64, 0.8);
} the first selector is for the right-hand purple boxes. the 16n + 2 makes sure that the styling applies to every 16th grid item, starting with the second item. the second selector targets the right-hand boxes. it uses the same spacing (16n) but with a different offset (10). as a result, these boxes appear regularly on the right-hand side for grid items 10, 26, 42, etc. when it comes to the visual styling for these grid items and their contents, i used another trick to reduce repetition. for styles that both boxes share (such as the background-color, for example) a single selector can be used to target both: .article:nth-child(8n + 2) {
  background: rgba(128, 0, 64, 0.8);
  /* other shared syling */
} this will target items 2, 10, 18, 26, 34, 42, 50, and so forth. in other words, it selects both the left- and right-hand featured boxes. it works because 8n is exactly half of 16n, and because the offsets used in the two separate selectors have a difference of 8 (i.e. the difference between +10 and +2 is 8) final thoughts right now, css grid can be used to create flexible responsive grids with minimal code, but this does come with some significant limitations on positioning elements without the retrograde step of using media queries. it would be great to be able to specify spans that would not force overflow on smaller screens. at the moment, we effectively tell the browser, ‚Äúmake a responsive grid, please,‚Äù which it does beautifully. but when we continue by saying, ‚Äúoh, and make this grid item span four columns,‚Äù it throws a hissy-fit on narrow screens, prioritizing the four-column span request rather than the responsive grid. it would be great to be able to tell grid to prioritize responsiveness over our span request. something like this: .article {
  grid-column: span 3, autofit;
} another issue with responsive grids is the last row. as the screen width changes the last row will frequently not be filled. i spent a long time looking for a way to make the last grid item span (and hence fill) the remaining columns, but it seems you can‚Äôt do it in grid right now. it would be nice if we could specify the item‚Äôs start position with a keyword like auto meaning, ‚Äúplease leave the left-hand edge wherever it falls.‚Äù like this: .article {
  grid-column: auto, -1;
} ‚Ä¶which would make the left-hand edge span to the end of the row. our learning partner wanna learn modern css layout? laying out designs on the web with css has gotten a lot more powerful in recent years. css grid and flexbox are incredibly powerful tools for that, and frontend masters has a complete learning course on them from jen kramer. wanna learn modern css layout? laying out designs on the web with css has gotten a lot more powerful in recent years. css grid and flexbox are incredibly powerful tools for that, and frontend masters has a complete learning course on them from jen kramer. comments james permalink to comment# february 25, 2020 love this! thank you. how would you approach styling content pushed from a cms where an editor might want to prioritize certain articles rather than using an nth-child(n+n) formula? reply jace cotton permalink to comment# february 25, 2020 not the author but i do something similar in my cms system. just create a utility class like ‚Äúfeatured‚Äù or ‚Äúhighlighted‚Äù, and have that selectable from a dropdown (in drupal, for example, i use a taxonomy term). jace cotton permalink to comment# february 25, 2020 great article! i think i spotted a mistake. when there is a conflict between implicit (automatic) columns and an implicit number of columns, grid always defers to the explicit grid; did you mean ‚Äúimplicit (automatic) columns and an explicit number of columns‚Äù? reply vanderson permalink to comment# february 25, 2020 thank you for this. i‚Äôve been working on a responsive grid framework for a long time and i simply had not considered the 1-3 (-1/-3) column start/end simplicity you demonstrate here. i had almost given up on a clean way to make auto-columns work. (i was about to go back to flexbox‚Ä¶ sigh) i have open-sourced this work, but after this i hesitate to share the link now because i plan to implement some of this into the framework. again thanks for putting the time into documenting this (especially the graph with the column placements using the various combinations of start/end) reply designer permalink to comment# february 25, 2020 wow! incredible work. love minimalist light code. reply ian permalink to comment# february 25, 2020 this is great. i‚Äôll spend more tome on it when i have it. i built a fluid asymmetric column grid system for my self based upon modular scale ratios. so i‚Äôm keen to see if i can improve my build with some of your thoughts reply shyamkant vasekar permalink to comment# february 25, 2020 i am reading this article on my mobile screen which resolution might be 460 . i can read it very convenently. thanks for introducing with such professional techniques. reply justin permalink to comment# february 25, 2020 great and insightful article. thanks for taking the time to break this down visually! reply andrew beeken permalink to comment# february 26, 2020 this is excellent stuff! grid‚Äôs been a huge game changer for me regarding how i lay out content (bring on wide implementation of sub-grid, please!) and this just shows how powerful it can be! i‚Äôve been doing a lot of experimentation with different layouts but writing so many media queries can get tedious ‚Äì ths is a great alternative and i‚Äôll be sure to drop it into more projects going forwards! reply aaron throckmorton permalink to comment# february 26, 2020 what a great article! not only did you demonstrate the dynamic grid, but you also took us through the process of trial and error you went through to figure it out. that is worth it‚Äôs weight in platinum. thanks so much! reply jameson permalink to comment# february 28, 2020 this article is great. thank you so much for all the work and helpful figures! exactly what i was looking for. reply florian permalink to comment# february 29, 2020 hi keir! this was very inspiring! now i‚Äôm wondering how you would go about laying out the actual articles. would you go with a one column layout like most blogs or have you tried multi-column layouts like magazines and newspapers use? i‚Äôm experimenting with a multi-column article layout myself. i am now stuck at deciding on when to insert something like a page break (the height of the columns before scrolling down to the next set of columns ‚Äì like flipping the page in a magazine). do you have any experience or input on this topic? reply marc haunschild permalink to comment# march 3, 2020 why desktop first? and px ‚Äì really? you definitely want people, that use big texts to fall back to the mobile layout! ‚Äì i would expect soemthing like this: .archive {
  display: flex;
  flex-direction: column;
}

/* multi column grid for wide viewports */
@media (min-width: 30em) {
.archive {
    [...]
  }
}
 reply leave a reply cancel reply your email address will not be published. required fields are marked * comment name * email * website save my name, email, and website in this browser for the next time i comment. get the css-tricks newsletter notify me of follow-up comments by email. copy and paste this code: micuno * leave this field empty all comments are held for moderation. we'll publish all comments that are on topic, not rude, and adhere to our code of conduct. you'll even get little stars if you do an extra good job. you may write comments in markdown. this is the best way to post any code, inline like `<div>this</div>` or multiline blocks within triple backtick fences (```) with double new lines before and after. want to tell us something privately, like pointing out a typo or stuff like that? contact us. we have a code of conduct. be cool. be helpful. the web is a big place. have fun. high five. related how do you stay up to date in this fast‚Å†-‚Å†moving industry? a good start is to sign up for our weekly hand-written newsletter. we bring you the best articles and ideas from around the web, and what we think about them. email address subscribe facebook @csstricks twitter @css youtube @realcsstricks instagram @real_css_tricks rss feed css-tricks* is created, written by, and maintained by chris coyier and a team of swell people. the tech stack for this site is fairly boring. that's a good thing! i've used wordpress since day one all the way up to v17, a decision i'm very happy with. i also leverage jetpack for extra functionality and local for local development. *may or may not contain any actual "css" or "tricks". other nav contact about guest writing jobs advertise license subscribe all authors codepen codepen is a place to experiment, debug, and show off your html, css, and javascript creations. flywheel logo flywheel css-tricks is hosted by flywheel, the best wordpress hosting in the business, with a local development tool to match. shoptalk is a podcast all about front-end web design and development. css-tricks presents üìÖ upcoming front-end conferences css-tricks presents the power of serverless for front-end developers