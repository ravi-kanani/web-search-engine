skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author max works as an open source developer at thinkmill, where he takes care of keystonejs and elementalui. he’s also the creator of react-boilerplate, the … more about max stoiber … january 16, 2017 leave a comment styled components: enforcing best practices in component-based systems 8 min read coding, javascript, web components share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → the rise of javascript frameworks such as react, ember and recently angular 2, the effort of the w3c to standardize a web-native component system, pattern libraries and style guides being considered the “right way” to build web applications, and many other things have illuminated this revolution. after this shift in mindset towards building component-based user interfaces, we are now in what we like to call the “component age.” the rise of javascript frameworks such as react, ember and recently angular 2, the effort of the w3c to standardize a web-native component system, pattern libraries and style guides being considered the “right way” to build web applications, and many other things have illuminated this revolution. a button react component written with styled components. (view large version) best practices in component-based systems as we’ve built more and more apps with components, we’ve discovered some best practices when working with them. i want to talk about three main ones today: building small, focused and independent components; splitting container and presentational components; and having single-use css class names. further reading on smashingmag: styling web components using a shared style sheet a glimpse into the future with react native for web finally, css in javascript! meet cssx build-small components instead of relying on classes for composition, use components to your advantage and compose them together. for example, imagine a button component that renders <button class=“btn”> to the dom. one could also render a bigger, more important button. making a bigger button would be as easy as attaching the btn–primary class in the dom: <button class=“btn btn–primary”>. instead of forcing users of the component to know which particular class to attach, the button component should have a primary property. making a primary button would be as easy as <button primary />! here is how we could implement this: // button.js

function button(props) {
  const classname = `btn${props.primary ? ' btn—-primary' : ''}`
  return (
    <button classname={classname}>{props.children}</button>
  );
}
 now, users no longer need to know which particular class it applies; they just render a primary button. what happens when the primary property is set is an implementation detail of the component. changing the styling, classes or behavior of the button now requires editing only a single file where the component is created, instead of hundreds of files where it is used. split container and presentational components with react, some of your components may have state associated with them. try to split components that handle data and/or logic (for example, data formatting) from components that handle styling. by separating these two concerns, reasoning about changes in your code base will be a lot easier. if the back-end api format has to change, all you have to do is go into your container components and make sure you render the same presentational components as before, even with the new format, and everything will work perfectly fine. on the other hand, if the visual design or user experiences of your app have to change, all you have to do is go into your presentational components and make sure they look correct on their own. because these components don’t care about when and where they’re rendered, and you haven’t changed which components get rendered, everything will work perfectly fine. by separating these two types of components, you avoid doing multiple unrelated changes at the same time, thus avoiding accidental errors. have single-use class names going back to our button component, it has a .btn class. changing the styles of that class should not affect anything except the button. if changing the background-color in my .btn class messes up the layout of the header and gives the footer two columns instead of three, then something is wrong. that violates the entire premise of having independent components. this essentially boils down to using every class in your css only once (outside of “mixins” like .clearfix). this way, bugs like the one above can never happen. the problem, as always, is us humans. ever encountered a bug in a program? it was only there because a human put it there. if programs could exist without humans, then bugs would not be a thing. human error accounts for every single bug you’ve ever found and squashed. there is a famous joke in the front-end development world: two css properties walk into a bar. a barstool in an entirely different bar falls over. the reception and repetition this joke has gotten tells you how many developers have seen this type of bug before. it happens, especially in teams, no matter how hard you try to avoid it. with that and a few other things in mind, glen maddern and i sat down and started thinking about styling in this new era. we didn’t want to reinvent or get rid of css; it’s a language that’s made for styling and that browsers natively support. let’s instead take the best parts of css and make human error in component-based systems almost impossible. enforcing best practices the basic idea of styled components is to enforce best practices by removing the mapping between styles and components. if you think about any styling method you’ve used, there is always a mapping between a style fragment and your html. with standard css, this would be a class name (or maybe an id). with styles in javascript libraries in react, it’s either setting a class from a variable or passing a javascript object to the style property. because we want to use each class only once, what if we just removed that mapping? as it turns out, by doing so, we also enforce the split between container and presentational components, and we make sure that developers can only build small and focused components. another interesting feature of styled components is that it allows you to write actual css in your javascript (not just css-as-javascript objects). it leverages an infrequently used feature of ecmascript 2015 (the new version of the javascript standard), called tagged template literals, to make that work a pleasant experience for the developer. the basics now, you might be wondering what that looks like. well, let’s take a look! const title = styled.h1`
  color: palevioletred;
  font-size: 1.5em;
  text-align: center;
`;
 you can now use this react component like any other: <wrapper>
  <title>hello world, this is my first styled component!</title>
</wrapper> this is what the component above looks like in the browser. (view large version) quite a few things are going on here, so let’s dissect this code snippet. styled.h1 is a function that, when called, returns a react component that renders an <h1> into the dom. if you’re wondering, “where do we call that function? i see only backticks, no parentheses!” that’s exactly where the ecmascript 2015 features come into play. what you’re seeing above is a tagged template literal, which is a new feature of javascript the language. (no special tooling is needed to use styled-components.) you can call functions with backticks (like styled.h1``), and they will receive the string passed in as the first argument. as we go along, you’ll see how this differs from calling functions normally with parentheses, but let’s leave it at this for now. so, this styled.h1 call returns a react component. this react component has a class attached to it that styled components automatically generates and uniquifies. this class name has the styles associated with it that you pass to the template literal. summed up, this means that the styled.h1 call returns a react component that has the styles applied that you pass to the template literal. full css support because styled-components is just css, it supports all of css perfectly fine. media queries, pseudo-selectors, even nesting just work. we are generating a class name and injecting the css into the dom; so, whatever works in css works with styled-components, too. const input = styled.input`
  font-size: 1.25em;
  border: none;
  background: papayawhip;
  /* ...more styles here... */

  &:hover {
    box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1);
  }

  @media (min-width: 650px) {
    font-size: 1.5em;
  }
`; this input component will now have nice hover styles and will resize itself to be a bit bigger on large screens. let’s see what one of these inputs looks like with and without a placeholder: this is what the component above looks like in the browser. (view large version) as you can see, making a container component that has styling or making a presentational component that has logic is impossible. we are also building a lot of small components and combining them into bigger containers, and because there are no visible classes, we cannot use them more than once. essentially, by using styled-components, we have to build a good component system — there is no other way. it enforces the best practices for us — no special architectural code review needed. wrapping up styled components offers a lot more great features, such as built-in theming and full react native support. i encourage you to dive into the documentation and try it out on one of your projects. not having to worry about best practices makes the development experience so much better and quicker. i’m obviously very biased, but i don’t ever want to go back to another way of styling react apps. here are a few miscellaneous links related to styles in javascript that aren’t specific to styled components but that talk about the topic more generally: “react js style components” (video), michael chan, full stack talks an amazing talk about leveraging components as a styling construct. if you’re using react and haven’t heard this talk yet, stop what you’re doing and watch it right now. “the magic behind ? styled-components”, max stoiber this article by yours truly dives deep into tagged template literals, how they work and why they are super useful, based on the example of styled-components. “the future of reusable css” (video), glen maddern, coldfront16 this talk by styled-components’ cocreator doesn’t talk about the library itself, but explains how theming component-based systems should work. a lot of these ideas have made their way into the library. “rendering khan academy’s learn menu wherever i please,” jordan scales a great article that documents the move of a complex code base from a handlebars and less combo to react and styles in javascript. highly recommended if you’re not sure whether either react or styles in javascript are for you. (rb, vf, il, yk, al) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top