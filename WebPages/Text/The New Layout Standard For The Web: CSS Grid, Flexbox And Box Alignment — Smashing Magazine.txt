skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author rachel andrew is not only editor in chief of smashing magazine, but also a web developer, writer and speaker. she is the author of a number of books, including … more about rachel andrew … november 8, 2016 leave a comment the new layout standard for the web: css grid, flexbox and box alignment 22 min read css, flexbox, css grid share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → editor’s note: please note that this article is quite lengthy, and contains dozens of codepen embeds for an interactive view. the page might take a little while to load, so please be patient. this article explains how flexbox and css grid fit together, and how we can build resilient and flexible layouts today while providing a decent fallback for older browsers. layout on the web is hard. the reason it is so hard is that the layout methods we’ve relied on ever since using css for layout became possible were not really designed for complex layout. while we were able to achieve quite a lot in a fixed-width world with hacks such as faux columns, these methods fell apart with responsive design. thankfully, we have hope, in the form of flexbox — which many readers will already be using — css grid layout and the box alignment module. in this article, i’m going to explain how these fit together, and you’ll discover that by understanding flexbox you are very close to understanding much of grid layout. new values for display both grid and flexbox are new values for the display property. to make an element a flex container, we use display: flex; to make it a grid container, we use display: grid. as soon as we do so, the immediate children of our flex or grid container become flex or grid items. those immediate children take on the initial values of flex or grid items. display: flex in the first example, we have three elements in a wrapper element set to display: flex. that’s all we need to do to start using flexbox. unless we add the following properties with different values, the initial values for the flex container are: flex-direction: row flex-wrap: no-wrap align-items: stretch justify-content: flex-start the initial values for our flex items are: flex-grow: 0 flex-shrink: 1 flex-basis: auto we’ll look at how these properties and values work later in this article. for now, all you need to do is set display: flex on a parent, and flexbox will begin to work. see the pen flexbox defaults by rachelandrew (@rachelandrew) on codepen. see the pen flexbox defaults by rachelandrew (@rachelandrew) on codepen. display: grid to lay out items on a grid, we use display: grid. in order that we can see the grid’s behavior, this example has five cards to lay out. adding display: grid won’t make a dramatic change; however, our child items are all now grid items. they have fallen into a single-column track grid, displaying one below the other, the grid creating implicit row tracks to hold each item. see the pen grid defaults by rachelandrew (@rachelandrew) on codepen. see the pen grid defaults by rachelandrew (@rachelandrew) on codepen. we can take our grid a step further and make it more grid-like by creating some columns. we use the grid-template-rows property to do this. in this next example, i’ve created three equal-width column tracks using a new unit that has been created for grid. the fr unit is a fraction unit signifying the fraction of available space this column should take up. you can see how our grid items have immediately laid themselves out on the grid, one in each created cell of our explicitly defined columns. the grid is still creating implicit rows; as we fill up the available cells created by our columns, new rows are created to hold more items. see the pen grid columns by rachelandrew (@rachelandrew) on codepen. see the pen grid columns by rachelandrew (@rachelandrew) on codepen. once again, we have some default behavior in evidence. we haven’t positioned any of these grid items, but they are placing themselves onto our grid, one per cell of the grid. the initial values of the grid container are: grid-auto-flow: row grid-auto-rows: auto align-items: stretch justify-items: stretch grid-gap: 0 these initial values mean that our grid items are placed one into each cell of the grid, working across the rows. because we have a three-column track grid, after filling the grid cell of the third column, a new row is created for the rest of the items. this row is auto-sized, so will expand to fit the content. items stretch in both directions, horizontal and vertical, filling the grid area. box alignment in both of these simple examples, we are already seeing values defined in the box alignment module in use. “box alignment module level 3” essentially takes all of the alignment and space distribution defined in flexbox and makes it available to other modules. so, if you already use flexbox, then you are already using box alignment. let’s look at how box alignment works in flexbox and grid, and the problems that it helps us solve. equal-height columns something that was very easy to create with old-school table-based layouts, yet fiendishly difficult using positioning and floats, is equal-height columns. in the floated example below, our cards contain unequal amounts of content. we have no way of indicating to the other cards that they should visually take on the same height as the first card — they have no relationship to each other. see the pen floated columns by rachelandrew (@rachelandrew) on codepen. see the pen floated columns by rachelandrew (@rachelandrew) on codepen. as soon as we set the display property to grid or flex on a parent, we give the children a relationship to each other. that relationship enables the box-alignment properties to work, making equal-height columns simple. in the flex example below, our items have unequal amounts of content. while the background on each lines up, it doesn’t sit behind the content as it would for floated elements. because these items are displayed in a row, the property that controls this behavior is align-items. creating equal-height columns requires that the value be stretch — the initial value for this property. see the pen flexbox equal-height columns by rachelandrew (@rachelandrew) on codepen. see the pen flexbox equal-height columns by rachelandrew (@rachelandrew) on codepen. we see the same with grid layouts. below is the simplest of grid layouts, two columns with a sidebar and main content. i’m using those fraction units again; the sidebar has 1 fraction of the available space, and the main content 3 fractions. the background color on the sidebar runs to the bottom of the content. once again, the default value of align-items is stretch. see the pen grid equal-height columns by rachelandrew (@rachelandrew) on codepen. see the pen grid equal-height columns by rachelandrew (@rachelandrew) on codepen. alignment in flexbox we’ve seen how the default value of align-items for both grid and flexbox is stretch. for flexbox, when we use align-items, we are aligning them inside the flex container, on the cross axis. the main axis is the one defined by the flex-direction property. in this first example, the main axis is the row; we are then stretching the items on the cross axis to the height of the flex container. the height of the flex container is, in this case, determined by the item with the most content. (view large version) i could give the wrapper a height, and in this case the height of the flex container would be defined by that height. (view large version) we can use other values, instead of the default stretch: flex-start flex-end baseline stretch to control the alignment on the main axis, use the justify-content property. the default value is flex-start, which is why our items are all aligned against the left margin. we could instead use any of the following values: flex-start flex-end center space-around space-between the space-between and space-around keywords are especially interesting. with space-between, the space left over after the flex items have been displayed is distributed evenly between the items. (view large version) using space-around is similar except that the space left over is distributed on both sides of the items. you get a half-sized gap on each end. (view large version) you can see these properties and values in the codepen below. see the pen flexbox align and justify on a row by rachel (@rachelandrew) on codepen. see the pen flexbox align and justify on a row by rachel (@rachelandrew) on codepen. see the pen flexbox alignment flex-direction: row by rachelandrew (@rachelandrew) on codepen. see the pen flexbox alignment flex-direction: row by rachelandrew (@rachelandrew) on codepen. we can display flex items as a column rather than a row. if we change the value of flex-direction to column, then the main axis becomes the column, and the cross axis is along the row — align-items is still stretch by default, and so stretches the items across row-wise. (view large version) if instead we want them to align to the start of the flex container, we use flex-start. (view large version) we can use justify-items, too, including space-between and space-around. the container needs to have enough height for you to see each in action, though! (view large version) see the pen flexbox alignment flex-direction: column by rachelandrew (@rachelandrew) on codepen. see the pen flexbox alignment flex-direction: column by rachelandrew (@rachelandrew) on codepen. alignment in grid layout in a grid layout, the behavior is similar, except that we are aligning items within the defined grid area. in flexbox, we talk about the main and cross axis; with grids, we use the terms “block” or “column axis” to describe the axis defining our columns, and “inline” or “row axis” to describe the axis defining our rows. we can align content inside a grid area using the properties and values described in the box alignment specification. a grid area is one or more grid cells. in the example below, we have a four-column and four-row track grid. the tracks are separated by a grid gap of 10 pixels, and i have created three grid areas using line-based positioning. we’ll look at this positioning properly later in this guide, but the value before the / is the line that the content starts on, and the value after where it ends. see the pen grid alignment: align-items and justify-items by rachelandrew (@rachelandrew) on codepen. see the pen grid alignment: align-items and justify-items by rachelandrew (@rachelandrew) on codepen. the dotted border is on a background image, to help us see the defined areas. so, in the first example, each area uses the defaults of stretch for both align-items on the column axis and justify-items on the row axis. this means that the content stretches to completely fill the defined area. (view large version) in the second example, i have changed the value of align-items on the grid container to center. we can also change this value on an individual grid item using the align-self property. in this case, i have set all items to center, but item two to stretch. (view large version) in the third example, i have changed the value of justify-items and justify-self again, setting these to center and stretch. (view large version) in all of the examples above, i have aligned the content of the grid areas, the areas defined by the start and end grid lines. we can also align the entire grid inside the container, if our grid tracks are sized so that they take up less space than the container that has been set to display: grid. in this case, we use the align-content and justify-content properties, as with flexbox. see the pen grid alignment: aligning the grid by rachelandrew (@rachelandrew) on codepen. see the pen grid alignment: aligning the grid by rachelandrew (@rachelandrew) on codepen. in the first example, we see the default alignment of a grid where the columns and rows have been defined in absolute units and take up less space than the fixed-sized wrapper allows for. the default values for both are start. (view large version) to move the tracks to the bottom right, we change the values to end. (view large version) just as with flexbox, we can use space-around and space-between. this might cause some behavior that we don’t want as the grid gaps essentially become wider. however, as you can see from the image below and in the third example in the codepen, we get the same space between or around the tracks as we see with flexbox. (view large version) the fixed-sized tracks will gain additional space if they span more than one track. element two and four in our example are wider and three is taller because they are given the extra space assigned to the gap they span over. we can completely center the grid by setting both values to center, as shown in the last example. (view large version) we have very nice alignment abilities in both flexbox and grid, and they work in a generally consistent way. we can align individual items and groups of items in a way that is responsive and prevents overlap — something the web has lacked until now! responsive by default in the last section, we looked at alignment. the box-alignment properties as used in grid and flexbox layouts are one area where we see how these specifications have emerged in a world where responsive design is just how things are done. values such as space-between, space-around and stretch allow for responsiveness, distributing content equally among or between items. there is more, however. responsive design is often about maintaining proportion. when we calculate columns for a responsive design using the target ÷ context approach, we maintain the proportions of the original absolute-width design. flexbox and grid layouts give us far simpler ways to deal with proportions in our designs. flexbox gives us a content-out approach to flexibility. we see this when we use a keyword value of space-between to space our items evenly. first, the amount of space taken up by our items is calculated, and then the remaining space in the container is divided up and used evenly to space out the items. we can get more control of content distribution by way of properties that we apply to the flex items themselves: flex-grow flex-shrink flex-basis these three properties are more usually described by the shorthand flex property. if we add flex: 1 1 300px to an item, we are stating that flex-grow should be 1 so that items can grow, flex-shrink should be 1 so that items can shrink, and the flex-basis should be 300 pixels. applying this to our cards layout gives us the example below. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. our flex-basis here is 300 pixels, and we have three cards in a row. if the flex container is wider than 900 pixels, then the remaining space is divided into three and distributed between the items equally. this is because we have set flex-grow to 1 so that our items can grow from the flex-basis. we have also set flex-shrink to 1, which means that, where we don’t have space for three 300-pixel columns, space will be removed equally. if we want these items to grow in different proportions, then we can change the flex-grow value on one or more items. if we would like the first item to get three times the available space distributed to it, we would set flex-grow to 3. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. the available space is distributed after the amount needed for flex-basis has been taken into account. this is why our first item is not three times the size of our other items, but instead gets a share of three parts of the remaining space. you will see a bigger change by setting the value for flex-basis to 0, in which case we wouldn’t have a starting value to remove from the overall container. then, the entire width of the container could be distributed in proportion to our items. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. a very useful tool to help you understand these values is flexbox tester. pop the different values into the tester, and it calculates the actual sizes at which your items will end up, and explains why they end up at that size. if you use auto as your flex-basis value, it will use any size set on the flex item as the flex-basis value. if there is no size, then it defaults to be the same as the value of content, which is the content’s width. using auto is, therefore, very useful for reusable components that might need to have a set size on an item. you can use auto and be sure that if the item needs to be around a size defined on it, flexbox will respect it. in the next example, i have set the flex-basis on all cards to auto. i then gave the first card a width of 350 pixels. so, the flex-basis of that first card is now 350 pixels, which is used to work out how to distribute space. the other two cards have a flex-basis based on their content’s width. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: flex properties by rachelandrew (@rachelandrew) on codepen. if we go back to our original flex: 1 1 300px, add more items to our example and set flex-wrap: wrap on the container, the items will wrap in order to maintain as near as possible the flex-basis value. if we have five images and three fit onto one row, then the next two will wrap onto a new row. as the items are allowed to grow, they both grow equally, and so we get two equal-sized items on the bottom row and three in the row above. see the pen flexbox: wrapping by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: wrapping by rachelandrew (@rachelandrew) on codepen. the question then asked is often, “how can i get the items on the bottom row to line up with the ones on the top, leaving a gap at the end?” the answer is that you don’t, not with flexbox. for that kind of behavior you need a grid layout. keeping things in proportion with grid layout grid layouts, as we have already seen, have a concept of creating column and row tracks into which items can be positioned. when we create a flexible grid layout, we set the proportions when defining the tracks on the grid container — rather than on the items, as with flexbox. we encountered the fr unit when we created our grids earlier. this unit works in a similar way to flex-grow when you have a flex-basis of 0. it assigns a fraction of the available space in the grid container. in this code example, the first column track has been given 2fr, the other two 1fr. so, we divide the space into four and assign two parts to the first track and one part each to the remaining two. see the pen simple grid showing fraction units by rachelandrew (@rachelandrew) on codepen. see the pen simple grid showing fraction units by rachelandrew (@rachelandrew) on codepen. mixing absolute units and fr units is valid. in this next example, we have a 2fr track, a 1fr track and a 300-pixel track. first, the absolute width is taken away, and then the remaining space is divided into three and assigned three parts to track 1 and one part to track 2. see the pen grid: mixing absolute and fraction units by rachelandrew (@rachelandrew) on codepen. see the pen grid: mixing absolute and fraction units by rachelandrew (@rachelandrew) on codepen. what you can also see from this example is that our items fit into the defined tracks — they don’t distribute across the row, as they do in the flexbox example. this is because, with grid layouts, we are creating a two-dimensional layout, then putting items into it. with flexbox, we get our content and work out how much will fit in a single dimension in a row or column, treating additional rows or columns as entirely new flex containers. what would be nice, however, is to still have a way to create as many columns of a certain size as will fit into the container. we can do this with grid and the repeat syntax. in the next example, i will use the repeat syntax to create as many 200-pixel columns as will fit in our container. i am using the repeat syntax for the track listing, with a keyword value of auto-fill and then the size that i want the repeated tracks to be. (at the time of writing, this was not implemented in chrome, but works in firefox developer edition.) see the pen grid: as many 200-pixel tracks as will fit by rachelandrew (@rachelandrew) on codepen. see the pen grid: as many 200-pixel tracks as will fit by rachelandrew (@rachelandrew) on codepen. we can go a step further than that and combine fraction units and an absolute width to tell the grid to create as many 200-pixel tracks as will fit in the container and to distribute the remainder equally. see the pen grid: as many 200-pixel tracks as will fit, distributing remaining space evenly by rachelandrew (@rachelandrew) on codepen. see the pen grid: as many 200-pixel tracks as will fit, distributing remaining space evenly by rachelandrew (@rachelandrew) on codepen. in this way, we get the benefits of a two-dimensional layout but still have flexible quantities of tracks — all without using any media queries. what we also see here is the grid and flexbox specifications diverging. where flexbox ends with distributing items in one dimension, grid is just getting started. a separation of source order and visual display with flexbox, we can’t do a lot in terms of positioning our flex items. we can choose the direction in which they flow, by setting flex-direction to row, row-reverse or column, column-reverse, and we can set an order, which controls the visual order in which the items display. see the pen flexbox: order by rachelandrew (@rachelandrew) on codepen. see the pen flexbox: order by rachelandrew (@rachelandrew) on codepen. with grid layouts, we get to properly position child items onto the grid we have defined. in most of the examples above, we have been relying on grid auto-placement, the rules that define how items we have not positioned are laid out. in the example below, i am using line-based positioning to position the items on the grid. the grid-column and grid-row properties are a shorthand for grid-column-start, grid-row-start, grid-column-end and grid-row-end. the value before the / is the line that the content starts on, while the value after is the line it ends on. see the pen grid: line-based positioning by rachelandrew (@rachelandrew) on codepen. see the pen grid: line-based positioning by rachelandrew (@rachelandrew) on codepen. you can also name your lines. this happens when you create your grid on the grid container. name the lines in brackets, and then position the items as before but using the names instead of the line index. see the pen grid: line-based positioning, named lines by rachelandrew (@rachelandrew) on codepen. see the pen grid: line-based positioning, named lines by rachelandrew (@rachelandrew) on codepen. you can have multiple lines with the same name, and then target them by line name and index. you can use a span keyword, spanning a number of lines or, for example, to the third line named col. this type of positioning is useful for creating components that sit in various places in the layout. in the example below, i want some elements to span six column tracks and others to span three. i am using auto-placement to lay out the items, but when the grid encounters an item with a class of wide, the start value will be auto and the end value will be span 2; so, it will start on the line it would normally start on based on the auto-placement rules, but span two lines. see the pen grid: multiple lines with the same name by rachelandrew (@rachelandrew) on codepen. see the pen grid: multiple lines with the same name by rachelandrew (@rachelandrew) on codepen. using auto-placement with some rules in this way will likely leave some gaps in our grid as the grid encounters items that need two tracks and has space for only one. by default, the grid progresses forward; so, once it leaves a gap, it doesn’t go back to place things in it — unless we set grid-auto-flow to a value of dense, in which case, the grid will actually backfill the gaps left, taking the content out of dom order. see the pen grid: grid-auto-flow: dense by rachelandrew (@rachelandrew) on codepen. see the pen grid: grid-auto-flow: dense by rachelandrew (@rachelandrew) on codepen. there is also a whole different method of positioning items using the grid layout — by creating a visual representation of our layout right in the value of the grid-template-areas property. to do this, you first need to name each direct child of the grid container that you want to position. we then lay the items out in this ascii art manner as the value of grid-template-areas. if you wanted to entirely redefine the layout based on media queries, you could do so just by changing the value of this one property! see the pen grid: template areas by rachelandrew (@rachelandrew) on codepen. see the pen grid: template areas by rachelandrew (@rachelandrew) on codepen. as you can see from the example, to leave a cell empty, we use a full stop or a series of full stops with no white space between them. to cause an element to span a number of tracks, we repeat the name. accessibility implications of reordering for flexbox and even more so for grid layouts, we need to take great care when using these methods to reorder content. the specification for flexbox states: authors must use order only for visual, not logical, reordering of content. style sheets that use order to perform logical reordering are non-conforming. for grids, we are warned: grid layout gives authors great powers of rearrangement over the document. however, these are not a substitute for correct ordering of the document source. the order property and grid placement do not affect ordering in non-visual media (such as speech). likewise, rearranging grid items visually does not affect the default traversal order of sequential navigation modes (such as cycling through links). in both cases, as currently defined, the reordering is only visual. it does not change the logical order of the document. in addition, we need to take great care in considering sighted keyboard users. it would be incredibly simple to cause someone tabbing through the document to tab along the navigation at the top and then suddenly be taken to the bottom of the document due to a grid item that appears early in the source being positioned there. a new system for css grid layout i’ve not covered every aspect of grid and flexbox in this guide - my aim being to show the similarities and differences between the specifications, and to throw box alignment into the mix. to demonstrate that what these specifications are bringing us is a new layout system, one that understands the kind of sites and applications we are building today. do play with the examples in the article, and there is a whole host of other stuff detailed in the resources below. i would be especially interested in use cases that you can’t achieve with these layout methods. if you find one let me know, i’m interested in finding the edges of the specifications we have so welcome a challenge. watch my talk resources here are some resources to help you explore these specifications further. grid by example, rachel andrew “laying out the future with grid and flexbox” (video), rachel andrew, mozilla hacks (ms, vf, ml, rb, al, il) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top