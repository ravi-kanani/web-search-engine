skip to main content css-tricks articles videos almanac snippets newsletter jobs guides back to top contact about archives advertise jobs license subscribe forums guest posting facebook twitter youtube instagram rss search for: search open search open navigation home / articles / web component for a code block author chris coyier 3 comments join conversation published feb 18, 2020 personalized marketing with mailchimp we'll get to that, but first, a long-winded introduction. i'm still not in a confident place knowing a good time to use native web components. the templating isn't particularly robust, so that doesn't draw me in. there is no state management, and i like having standard ways of handling that. if i'm using another library for components anyway, seems like i would just stick with that. so, at the moment, my checklist is something like: not using any other javascript framework that has components templating needs aren't particularly complex don't need particularly performant re-rendering don't need state management i'm sure there is tooling that helps with these things and more (the devmode episode with some folks from stencil was good), but if i'm going to get into tooling-land, i'd be extra tempted to go with a framework, and probably not framework plus another thing with a lot of overlap. the reasons i am tempted to go with native web components are: they are native. no downloads of frameworks. the shadow dom is a true encapsulation in a way a framework can't really do. i get to build my own html element that i use in html, with my own api design. it sorta seems like the sweet spot for native web components is design system components. you build out your own little api for the components in your system, and people can use them in a way that is a lot safer than just copy and paste this chunk of html. and i suppose if consumers of the system wanted to byo framework, they could. so you can use like <our-tabs active-tab="3"> rather than <div class="tabs"> ... <a href="#3" class="tab-is-active">. refactoring the components certainly gets a lot easier as changes percolate everywhere. i've used them here on css-tricks for our <circle-text> component. it takes the radius as a parameter and the content via, uh, content, and outputs an <svg> that does the trick. it gave us a nice api for authoring that abstracted away the complexity. so! it occurred to me a "code block" might be a nice use-case for a web component. the api would be nice for it, as you could have attributes control useful things, and the code itself as the content (which is a great fallback). it doesn't really need state. syntax highlighting is a big gnarly block of css, so it would be kinda cool to isolate that away in the shadow dom. it could have useful functionality like a "click to copy" button that people might enjoy having. altogether, it might feel like a yeah, i could use this kinda component. this probably isn't really production ready (for one thing, it's not on npm or anything yet), but here's where i am so far: codepen embed fallback here's a thought dump! what do you do when a component depends on a third-party lib? the syntax highlighting here is done with prism.js. to make it more isolated, i suppose you could copy and paste the whole lib in there somewhere, but that seems silly. maybe you just document it? styling web components doesn't feel like it has a great story yet, despite the fact that shadow dom is cool and useful. yanking in pre-formatted text to use in a template is super weird. i'm sure it's possible to do without needing a <pre> tag inside the custom element, but it's clearly much easier if you grab the content from the <pre>. makes the api here just a smidge less friendly (because i'd prefer to use the <code-block> alone). i wonder what a good practice is for passing along attributes that another library needs. like is data-lang="css" ok to use (feels nicer), and then convert it to class="language-css" in the template because that's what prism wants? or is it better practice to just pass along attributes as they are? (i went with the latter.) people complain that there aren't really "lifecycle methods" in native web components, but at least you have one: when the thing renders: connectedcallback. so, i suppose you should do all the manipulation of html and such before you do that final shadowroot.appendchild(node);. i'm not doing that here, and instead am running prism over the whole shadowroot after it's been appended. just seemed to work that way. i imagine it's probably better, and possible, to do it ahead of time rather than allow all the repainting caused by injecting spans and such. the whole point of this is a nice api. seems to me thing would be nicer if it was possible to drop un-escaped html in there to highlight and it could escape it for you. but that makes the fallback actually render that html which could be bad (or even theoretically insecure). what's a good story for that? maybe put the html in html comments and test if <!-- is the start of the content and handle that as a special situation? anyway, if you wanna fork it or do anything fancier with it, lemme know. maybe we can eventually put it on npm or whatever. we'll have to see how useful people think it could be. our learning partner need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. need some front-end development training? frontend masters is the best place to get it. they have courses on all the most important front-end technologies, from react to css, from vue to d3, and beyond with node.js and full stack. comments justin ribeiro permalink to comment# february 18, 2020 the problem with most of the highlighters is that they don‚Äôt use es modules and it‚Äôs makes them hard to consume. justin fagnani and i have talked about this previously (ala, registries and custom namespaces). my code-block web component uses prism and litelement in a particularly dynamic loading way to cut weight and make it flexible: https://github.com/justinribeiro/code-block and is available on npm https://www.npmjs.com/package/@justinribeiro/code-block i use it on my site extensively and in internal projects. it‚Äôs by no means ideal (themes work for instance, but i haven‚Äôt revisited making it easier to handle). fagnani forked rainbow to handle his case, updating it to make the module experience better (https://www.npmjs.com/package/@justinfagnani/rainbow). reply jamie permalink to comment# february 19, 2020 one small things solved: [ ] wtf with the !important on the pre background. not sure what that is overriding but seems to be necessary. turns out, you need to get rid of the background: none;
 so it becomes this: pre[class*="language-"] {
  background: #111;
  color: white;
 this was just a small overlook on your part :) reply chris coyier permalink to comment# february 19, 2020 derp! leave a reply cancel reply your email address will not be published. required fields are marked * comment name * email * website save my name, email, and website in this browser for the next time i comment. get the css-tricks newsletter notify me of follow-up comments by email. copy and paste this code: micuno * leave this field empty all comments are held for moderation. we'll publish all comments that are on topic, not rude, and adhere to our code of conduct. you'll even get little stars if you do an extra good job. you may write comments in markdown. this is the best way to post any code, inline like `<div>this</div>` or multiline blocks within triple backtick fences (```) with double new lines before and after. want to tell us something privately, like pointing out a typo or stuff like that? contact us. we have a code of conduct. be cool. be helpful. the web is a big place. have fun. high five. related how do you stay up to date in this fast‚Å†-‚Å†moving industry? a good start is to sign up for our weekly hand-written newsletter. we bring you the best articles and ideas from around the web, and what we think about them. email address subscribe facebook @csstricks twitter @css youtube @realcsstricks instagram @real_css_tricks rss feed css-tricks* is created, written by, and maintained by chris coyier and a team of swell people. the tech stack for this site is fairly boring. that's a good thing! i've used wordpress since day one all the way up to v17, a decision i'm very happy with. i also leverage jetpack for extra functionality and local for local development. *may or may not contain any actual "css" or "tricks". other nav contact about guest writing jobs advertise license subscribe all authors codepen codepen is a place to experiment, debug, and show off your html, css, and javascript creations. flywheel logo flywheel css-tricks is hosted by flywheel, the best wordpress hosting in the business, with a local development tool to match. shoptalk is a podcast all about front-end web design and development. css-tricks presents üìÖ upcoming front-end conferences css-tricks presents the power of serverless for front-end developers