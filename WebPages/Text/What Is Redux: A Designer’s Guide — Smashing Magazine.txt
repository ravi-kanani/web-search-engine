skip to main content start reading the article jump to list of all articles search topics articles . design & development books . physical & digital books events . conferences & workshops jobs . find work & employees membership . webinars & early-birds browse all topics clear search browse all topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow about the author teaching designers react at learnreact.design. developer. lifelong learner. more about linton ye … july 5, 2018 leave a comment what is redux: a designer’s guide 15 min read coding, tools, javascript share on twitter or linkedin smashing newsletter upgrade your inbox and get our editors’ picks 2× a month — delivered right into your inbox. earlier issues. your (smashing) email subscribe → do you know redux’s real power is beyond managing the state? do you want to design with an understanding of how redux works in mind? let’s dig deeper into what redux can do, why it does its things, what the downsides are, and how it relates to design. have you heard of redux? what is it? no googling, please! “fancy backend stuff.” “i have heard of it, but i’m not aware of what it is. it’s a react framework perhaps?” “a better way to store and manage states in a react application.” i’ve asked this question to over 40 designers. the above are their typical answers. many of them are aware that redux works with react and its job is “state management.” but do you know what this “state management” really means? do you know redux’s real power is beyond managing the state? do you know that redux doesn’t necessarily require react to work? do you want to join your team’s discussion (or at least lunch chats) about whether to use redux? do you want to design with an understanding of how redux works in mind? with the help of this article, i’d like to show you a full picture of redux: what it can do, why it does its things, what the downsides are, when to use it, and how it relates to design. my goal is to help designers like you. even if you haven’t written a single line of code before, i think it’s still possible and beneficial (and fun) to understand redux. expect plain english and doodles — no code or abstract talks. ready for the ride? what is redux? at a super-high level, redux is a tool that developers use to make their lives easier. as many of you might have heard, its job is “state management.” i’ll explain what state management means a few sections later. at this point, i’ll leave you with this picture: redux manages state, but in the background, there are a few hidden powers. (illustration by beebee) (large preview) why should you care? redux is more about the inner workings of an app than its look-and-feel. it’s a somewhat complex tool with a steep learning curve. does that mean we, as designers, should stay far away from it? no. i think we should embrace it. a car designer should understand what the engine is for, right? to successfully design app interfaces, designers should also have solid knowledge about things under the hood. we should learn about what it can do, understand why developers use it, and be aware of its advantages and implications. “design is not just what it looks like and feels like. design is how it works.” — steve jobs what can redux do? many people use redux to manage the state in react apps. it’s the most common use case in the wild and redux improves the aspects where react doesn’t do well (yet). however, you’ll soon see that the real power of redux goes way beyond that. let’s get started by learning what state management really means. state management if you are not sure what this “state” means, let’s replace it with a more generic term: “data.” state is data that change from time to time. state determines what’s displayed on the user interface. what does state management mean? in general, there are three aspects of data that we’d need to manage in an app: fetching and storing data assigning data to ui elements changing data let’s say we are building a dribbble shot page. what is the data we want to display on the page? they include the author’s profile photo, name, the animated gif, the number of hearts, the comments, and so on. data on a dribbble shot page (large preview) first, we need to fetch all these data from a server in the cloud and put it somewhere. next, we need to actually display the data. we need to assign pieces of this data to corresponding ui elements that represent what we actually see in the browser. for example, we assign the url of the profile photo to the src attribute of an html img tag: <img src='https://url/to/profile_photo'>
 finally, we need to handle changes to the data. for example, if a user adds a new comment to a dribbble shot, or adds a star, we need to update the html accordingly. coordinating these three aspects of state is a big part in front-end development, and react has various degree of support for this task. sometimes the built-in facility in react works well enough. but as the app grows more complex, its state may become harder to manage with react alone. that’s why many people start using redux as an alternative. fetching and storing data in react, we break down a ui into components. each of these components can be broken down into smaller components (see “what is react?”). dribbble shot page broken down into components (large preview) if our ui is structured this way, when do we fetch the data and where to store it before populating the ui? imagine there’s a chef living in each component. fetching data from servers is like sourcing all the ingredients needed to prepare dishes. a naive way is to fetch and store the data where and when it’s needed. this is like each chef going out to buy vegetables and meats directly from far-away farms. the naive way: fetch data from each component. (illustration by beebee) (large preview) this approach is wasteful. we’d need to call the server many times from many components — even for the same data. the chefs would waste a lot of gas and time traveling back and forth. with redux, we fetch data once and store it in a central place, conveniently called “store.” the data is then ready for use anytime by any component. this is not unlike having a superstore nearby where our chefs can buy all the ingredients. the superstore sends trucks to carry back vegetables and meats in bulk from farms. it’s a lot more efficient than asking individual chefs to go to the farms themselves! the store also serves as the single source of truth. components always retrieve data from the store, not from anywhere else. this keeps all the ui content consistent. redux as a central store of data. (illustration by beebee) (large preview) assigning data to ui elements with only react, there’s actually a better way to fetch and store data. we can ask our very kind chef shotwell to do the shopping for all his chef friends. he would drive a truck to the farms and carry back the goodies. we could fetch data from a container component, for example, the “shot” component in the dribbble example, and use that as the single source of truth. fetch data from the root component. (illustration by beebee) (large preview) this approach is more efficient than the naive way of fetching data from every component. but how does shotwell pass the ingredients to other chefs? how to pass the data to the components that actually render html elements? we pass data from outer components to inner components like the baton in a relay, all the way until the data reach the destination. for example, the url of the author avatar needs to be passed from “shot”, to “shotdetail”, to “title” and finally to the <img> tag. if our chefs live in an apartment, it really looks like this: pass data to components via props. (illustration by beebee) (large preview) to deliver data to the destination, we’d have to engage all the components on the path, even if they don’t need the data at all. it’d be really annoying if there are many floors! what if the superstore does door-to-door delivery? with redux1, we can plug in any data into any component, without affecting other components at all, like so: 1 to be absolutely accurate, it’s another library called react-redux that hands data to react components, not redux itself. but since react-redux just does the plumbing and people almost always use redux and react-redux together, i think it’s fine to include this as one of the benefits of redux. plug data into components with redux. (illustration by beebee) (large preview) note: in the latest version of react (16.3), there’s a new “context” api that does almost the same job in terms of plugging data into components. so if this is the only reason your team is using redux, seriously consider upgrading to react 16.3! check out the official document for more information (warning: lots of code ahead). changing data sometimes the logic of updating data in an app can be fairly complex. it might involve multiple steps that depend on one another. we may need to wait for the responses from multiple servers before updating the application state. we might need to update many places in the state at different times under different conditions. it can be overwhelming if we don’t have a good structure for all this logic. the code would be difficult to understand and maintain. redux allows us to divide and conquer. it provides a standard way to break data updating logic into small “reducers”. those reducers work harmoniously together to complete a complex action. divide complex logic into reducers. (illustration by beebee) (large preview) keep an eye on the recent development of react, though. as with the “context” api, there might be a new “setstate” api in a future version of react. it’d make it easier to break up complex update logic into smaller parts. once this new api becomes available, it’s possible that you won’t be needing redux anymore to manage this aspect of state management. the real power of redux so far, it seems redux is just a band-aid for react. people use redux to improve aspects that react doesn’t do well (yet). but react is catching up quickly! in fact, dan abramov, the creator of redux, joined the react core team at facebook a couple of years ago. they have been busy working on the aforementioned improvements to react: context api (released in 16.3), better data fetching api (demoed in feb 2018), a better setstate api and so on. will it make redux obsolete? guess what? i haven’t shown you the real power of redux yet! redux' power is way beyond state management. (illustration by beebee) (large preview) redux forces developers to follow a few strict rules, which bring redux a lot of power (yup, the power of discipline!): all the data (application state) has to be described in clear text. you should be able to write down all the data with a pen on paper. every action (change of data) has to be described in clear text. you must write down what you’ll do before changing anything. you can’t change data without leaving a mark. this process is called “dispatching an action” in redux slang. your code that changes data must behave like a math formula. it must return the same result given the same input. the square of 4 is always 16 no matter how many times you run it. when you follow these rules to build apps, magic happens. it enables a lot of cool features that are otherwise difficult or expensive to implement. here are some examples.2 2 i collected these examples from dan abramov’s post “you might not need redux” and his “react beginner question thread.” undo, redo the popular undo/redo feature requires system-level planning. because undo/redo needs to record and replay every single change of data in the app, you must take it into account in the architecture from the very beginning. if it’s done as an afterthought, it’d require changing a lot of files which is a recipe for countless bugs. undo, redo. (illustration by beebee) (large preview) because redux requires every action to be described in clear text, the support for undo/redo almost comes for free. the instructions of how to implement undo/redo with redux fit in a simple page. collaborative environment if you are building an app similar to google docs where multiple users work together on a complex task, consider using redux. it will likely do a lot of weightlifting for you. google docs (illustration by beebee) (large preview) redux makes it very easy to send what is happening over the network. it’s straightforward to receive actions another user performs on another machine, replay the changes and merge with what’s happening locally. optimistic ui optimistic ui is a way to improve the user experience of an app. it makes the app appear to respond faster over a slow network. it’s a popular strategy in apps that require real-time responses, for example, a first-person shooter game. optimistic ui (illustration by beebee) (large preview) as a simple example, in the twitter app, when you click the heart on a tweet, it needs to request the server to do a few checkups, for example, whether that tweet still exists. instead of waiting many seconds for the result, the app chooses to cheat! it assumes everything is ok and shows a filled heart right away. twitter heart (illustration by beebee) (large preview) this approach works because most of the time everything is ok. when things are not ok, the app will revert the previous ui updates and apply the actual result from the server, for example, show an error message. redux supports optimistic ui in the same fashion as what it does for undo and redo. it makes it easy to record, replay and revert changes of data when receiving a negative result from the server. persisting and booting up from state redux makes it easy to save what’s happening in an app in the storage. later on, even if the computer restarts, the app can load all the data and continue from exactly the same spot, as if it’s never been interrupted. save/load game progress (illustration by beebee) (large preview) if you build a game with redux, you’d just need a couple more lines of code to save/load the game progress, without changing the rest of the code. really extensible systems with redux, you must “dispatch” an action to update any data in an app. this restriction makes it possible to hook into almost every aspect of what’s happening in an app. you can build really extensible apps where every function can be customized by the user. for example, check out hyper, a terminal app built with redux. the “hyperpower” extension adds sprinkles to the cursor and shakes up the window. how do you like this “wow” mode? (perhaps not terribly useful but enough to impress users) the “wow” mode in hyper, a terminal app. (large preview) time-travel debugging how about being able to travel in time when debugging an app? you run the app, rewind or forward a few times to find the exact place when the bug occurs, fix the bug and re-play to confirm. redux makes this dream of developers come true. redux devtools allows you to manipulate the progress of a running app as a youtube video — by dragging a slider! how does it work? remember the three strict rules that redux enforces? that’s the secret sauce of the magic. time travel in redux devtools large preview automated bug reports imagine this: a user finds something wrong in your app and wants to report the bug. she painstakingly recalls and describes what she has done. a developer then tries to follow the steps manually to see if the bug occurs again. the bug report may be vague or inaccurate. the developer is having a hard time finding where the bug is. now, how about this. the user clicks the “report bug” button. the system automatically sends what she has done to the developer. the developer clicks the “replay bug” button and watches how that bug exactly happens. the bug is squashed on the spot, everybody is happy! this is exactly what would happen if you use redux bug reporter. how does it work? the redux restrictions make wonders. automated bug reports (illustration by beebee) (large preview) downsides of redux the three major rules that redux enforces are a double-edged sword. they enable powerful features, but at the same time cause inevitable downsides. steep learning curve redux has a relatively steep learning curve. it takes time to understand, remember and get used to its patterns. it’s not recommended to learn redux and react at the same time if they are both new to you. “boilerplate” code in many cases, using redux means writing more code. it’s often required to touch multiple files to get a simple feature working. people have been complaining about the “boilerplate” code they’d have to write with redux. i know, this sounds contradictory. didn’t i say redux makes it possible to implement features with minimal code? this is a bit like using a dishwasher. first, you’d have to spend the time carefully arranging the dishes in rows. not until then you will see the benefits of the dishwasher: saving time on actually cleaning the dishes, sanitizing the dishes etc. you have to decide whether the preparation time is worth it! performance penalty redux could also have an impact on performance due to the restrictions it enforces. it adds a little overhead whenever the data changes. in most cases, it’s not a big deal, and the slowdown is not noticeable. still, when there’s a large amount of data in the store and when the data changes frequently (e.g. when the user is typing rapidly on a mobile device), the ui may become sluggish as a result. bonus: redux is not just for react a common misconception is that redux is for react only. it sounds like redux can’t do anything without react. indeed, redux complements react in a few important ways, as we have discussed earlier. it’s the most common use case. however, in fact, redux can work with any front-end frameworks, such as angular, ember.js or even jquery, or even vanilla javascript. try googling it, you’ll find this, this, this or even this. the general ideas of redux apply anywhere! as long as you use redux wisely, you can get its benefits in many situations — not just in a react app. redux works well with other front-end libraries. (illustration by beebee) (large preview) conclusion as any tool, redux offers a tradeoff. it enables powerful features but also has inevitable drawbacks. the job of a development team is to evaluate whether the tradeoff is worth it and make a conscious decision. as designers, if we understand the advantages and downsides of redux, we’ll be able to contribute to this decision making from the perspective of design. for example, perhaps we could design the ui to mitigate the potential performance impact? perhaps we could advocate the inclusion of undo/redo features to remove a boatload of confirmation dialogs? perhaps we could suggest optimistic ui since it improves user experience with a relatively low cost? understand the benefits and limitations of a technology, and design accordingly. i think that’s what steve jobs meant by “design is how it works.” (rb, ra, il) browse all smashing magazine topics accessibility android animation apps css design design patterns design systems e-commerce freebies graphics html illustrator inspiration ios javascript mobile pattern libraries performance photoshop plugins react responsive web design service workers sketch typography ui usability user experience wallpapers web design wordpress workflow with a commitment to quality content for the design community. founded by vitaly friedman and sven lennartz. 2006–2020. smashing is proudly running on netlify. fonts by latinotype. ✎ write for us contact us about us (impressum) privacy policy membership login delivery times advertise back to top